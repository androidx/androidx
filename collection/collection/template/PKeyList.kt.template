/*
 * Copyright 2023 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
@file:Suppress("NOTHING_TO_INLINE", "RedundantVisibilityModifier")
@file:OptIn(ExperimentalContracts::class)

package androidx.collection

import androidx.annotation.IntRange
import androidx.collection.internal.throwIllegalArgumentException
import androidx.collection.internal.throwIndexOutOfBoundsException
import androidx.collection.internal.throwNoSuchElementException
import kotlin.contracts.ExperimentalContracts
import kotlin.contracts.contract
import kotlin.jvm.JvmField
import kotlin.jvm.JvmOverloads

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// DO NOT MAKE CHANGES to the kotlin source file.
//
// This file was generated from a template in the template directory.
// Make a change to the original template and run the generateCollections.sh script
// to ensure the change is available on all versions of the map.
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

/**
 * [PKeyList] is a [List]-like collection for [PKey] values. It allows retrieving
 * the elements without boxing. [PKeyList] is always backed by a [MutablePKeyList],
 * its [MutableList]-like subclass. The purpose of this class is to avoid the performance
 * overhead of auto-boxing due to generics since [Collection] classes all operate on objects.
 *
 * This implementation is not thread-safe: if multiple threads access this
 * container concurrently, and one or more threads modify the structure of
 * the list (insertion or removal for instance), the calling code must provide
 * the appropriate synchronization. It is also not safe to mutate during reentrancy --
 * in the middle of a [forEach], for example. However, concurrent reads are safe.
 */
public sealed class PKeyList(initialCapacity: Int) {
    @JvmField
    @PublishedApi
    internal var content: PKeyArray = if (initialCapacity == 0) {
        EmptyPKeyArray
    } else {
        PKeyArray(initialCapacity)
    }

    @Suppress("PropertyName")
    @JvmField
    @PublishedApi
    internal var _size: Int = 0

    /**
     * The number of elements in the [PKeyList].
     */
    @get:IntRange(from = 0)
    public val size: Int
        get() = _size

    /**
     * Returns the last valid index in the [PKeyList]. This can be `-1` when the list is empty.
     */
    @get:IntRange(from = -1)
    public inline val lastIndex: Int get() = _size - 1

    /**
     * Returns an [IntRange] of the valid indices for this [PKeyList].
     */
    public inline val indices: kotlin.ranges.IntRange get() = 0 until _size

    /**
     * Returns `true` if the collection has no elements in it.
     */
    public fun none(): Boolean {
        return isEmpty()
    }

    /**
     * Returns `true` if there's at least one element in the collection.
     */
    public fun any(): Boolean {
        return isNotEmpty()
    }

    /**
     * Returns `true` if any of the elements give a `true` return value for [predicate].
     */
    public inline fun any(predicate: (element: PKey) -> Boolean): Boolean {
        contract { callsInPlace(predicate) }
        forEach {
            if (predicate(it)) {
                return true
            }
        }
        return false
    }

    /**
     * Returns `true` if any of the elements give a `true` return value for [predicate] while
     * iterating in the reverse order.
     */
    public inline fun reversedAny(predicate: (element: PKey) -> Boolean): Boolean {
        contract { callsInPlace(predicate) }
        forEachReversed {
            if (predicate(it)) {
                return true
            }
        }
        return false
    }

    /**
     * Returns `true` if the [PKeyList] contains [element] or `false` otherwise.
     */
    public operator fun contains(element: PKey): Boolean {
        forEach {
            if (it == element) {
                return true
            }
        }
        return false
    }

    /**
     * Returns `true` if the [PKeyList] contains all elements in [elements] or `false` if
     * one or more are missing.
     */
    public fun containsAll(elements: PKeyList): Boolean {
        for (i in elements.indices) {
            if (!contains(elements[i])) return false
        }
        return true
    }

    /**
     * Returns the number of elements in this list.
     */
    public fun count(): Int = _size

    /**
     * Counts the number of elements matching [predicate].
     * @return The number of elements in this list for which [predicate] returns true.
     */
    public inline fun count(predicate: (element: PKey) -> Boolean): Int {
        contract { callsInPlace(predicate) }
        var count = 0
        forEach { if (predicate(it)) count++ }
        return count
    }

    /**
     * Returns the first element in the [PKeyList] or throws a [NoSuchElementException] if
     * it [isEmpty].
     */
    public fun first(): PKey {
        if (isEmpty()) {
            throwNoSuchElementException("PKeyList is empty.")
        }
        return content[0]
    }

    /**
     * Returns the first element in the [PKeyList] for which [predicate] returns `true` or
     * throws [NoSuchElementException] if nothing matches.
     * @see indexOfFirst
     */
    public inline fun first(predicate: (element: PKey) -> Boolean): PKey {
        contract { callsInPlace(predicate) }
        forEach { item ->
            if (predicate(item)) return item
        }
        throw NoSuchElementException("PKeyList contains no element matching the predicate.")
    }

    /**
     * Accumulates values, starting with [initial], and applying [operation] to each element
     * in the [PKeyList] in order.
     * @param initial The value of `acc` for the first call to [operation] or return value if
     * there are no elements in this list.
     * @param operation function that takes current accumulator value and an element, and
     * calculates the next accumulator value.
     */
    public inline fun <R> fold(initial: R, operation: (acc: R, element: PKey) -> R): R {
        contract { callsInPlace(operation) }
        var acc = initial
        forEach { item ->
            acc = operation(acc, item)
        }
        return acc
    }

    /**
     * Accumulates values, starting with [initial], and applying [operation] to each element
     * in the [PKeyList] in order.
     */
    public inline fun <R> foldIndexed(
        initial: R,
        operation: (index: Int, acc: R, element: PKey) -> R
    ): R {
        contract { callsInPlace(operation) }
        var acc = initial
        forEachIndexed { i, item ->
            acc = operation(i, acc, item)
        }
        return acc
    }

    /**
     * Accumulates values, starting with [initial], and applying [operation] to each element
     * in the [PKeyList] in reverse order.
     * @param initial The value of `acc` for the first call to [operation] or return value if
     * there are no elements in this list.
     * @param operation function that takes an element and the current accumulator value, and
     * calculates the next accumulator value.
     */
    public inline fun <R> foldRight(initial: R, operation: (element: PKey, acc: R) -> R): R {
        contract { callsInPlace(operation) }
        var acc = initial
        forEachReversed { item ->
            acc = operation(item, acc)
        }
        return acc
    }

    /**
     * Accumulates values, starting with [initial], and applying [operation] to each element
     * in the [PKeyList] in reverse order.
     */
    public inline fun <R> foldRightIndexed(
        initial: R,
        operation: (index: Int, element: PKey, acc: R) -> R
    ): R {
        contract { callsInPlace(operation) }
        var acc = initial
        forEachReversedIndexed { i, item ->
            acc = operation(i, item, acc)
        }
        return acc
    }

    /**
     * Calls [block] for each element in the [PKeyList], in order.
     * @param block will be executed for every element in the list, accepting an element from
     * the list
     */
    public inline fun forEach(block: (element: PKey) -> Unit) {
        contract { callsInPlace(block) }
        val content = content
        for (i in 0 until _size) {
            block(content[i])
        }
    }

    /**
     * Calls [block] for each element in the [PKeyList] along with its index, in order.
     * @param block will be executed for every element in the list, accepting the index and
     * the element at that index.
     */
    public inline fun forEachIndexed(block: (index: Int, element: PKey) -> Unit) {
        contract { callsInPlace(block) }
        val content = content
        for (i in 0 until _size) {
            block(i, content[i])
        }
    }

    /**
     * Calls [block] for each element in the [PKeyList] in reverse order.
     * @param block will be executed for every element in the list, accepting an element from
     * the list
     */
    public inline fun forEachReversed(block: (element: PKey) -> Unit) {
        contract { callsInPlace(block) }
        val content = content
        for (i in _size - 1 downTo 0) {
            block(content[i])
        }
    }

    /**
     * Calls [block] for each element in the [PKeyList] along with its index, in reverse
     * order.
     * @param block will be executed for every element in the list, accepting the index and
     * the element at that index.
     */
    public inline fun forEachReversedIndexed(block: (index: Int, element: PKey) -> Unit) {
        contract { callsInPlace(block) }
        val content = content
        for (i in _size - 1 downTo 0) {
            block(i, content[i])
        }
    }

    /**
     * Returns the element at the given [index] or throws [IndexOutOfBoundsException] if
     * the [index] is out of bounds of this collection.
     */
    public operator fun get(@IntRange(from = 0) index: Int): PKey {
        if (index !in 0 until _size) {
            throwIndexOutOfBoundsException("Index $index must be in 0..$lastIndex")
        }
        return content[index]
    }

    /**
     * Returns the element at the given [index] or throws [IndexOutOfBoundsException] if
     * the [index] is out of bounds of this collection.
     */
    public fun elementAt(@IntRange(from = 0) index: Int): PKey {
        if (index !in 0 until _size) {
            throwIndexOutOfBoundsException("Index $index must be in 0..$lastIndex")
        }
        return content[index]
    }

    /**
     * Returns the element at the given [index] or [defaultValue] if [index] is out of bounds
     * of the collection.
     * @param index The index of the element whose value should be returned
     * @param defaultValue A lambda to call with [index] as a parameter to return a value at
     * an index not in the list.
     */
    public inline fun elementAtOrElse(
        @IntRange(from = 0) index: Int,
        defaultValue: (index: Int) -> PKey
    ): PKey {
        if (index !in 0 until _size) {
            return defaultValue(index)
        }
        return content[index]
    }

    /**
     * Returns the index of [element] in the [PKeyList] or `-1` if [element] is not there.
     */
    public fun indexOf(element: PKey): Int {
        forEachIndexed { i, item ->
            if (element == item) {
                return i
            }
        }
        return -1
    }

    /**
     * Returns the index if the first element in the [PKeyList] for which [predicate]
     * returns `true`.
     */
    public inline fun indexOfFirst(predicate: (element: PKey) -> Boolean): Int {
        contract { callsInPlace(predicate) }
        forEachIndexed { i, item ->
            if (predicate(item)) {
                return i
            }
        }
        return -1
    }

    /**
     * Returns the index if the last element in the [PKeyList] for which [predicate]
     * returns `true`.
     */
    public inline fun indexOfLast(predicate: (element: PKey) -> Boolean): Int {
        contract { callsInPlace(predicate) }
        forEachReversedIndexed { i, item ->
            if (predicate(item)) {
                return i
            }
        }
        return -1
    }

    /**
     * Returns `true` if the [PKeyList] has no elements in it or `false` otherwise.
     */
    public fun isEmpty(): Boolean = _size == 0

    /**
     * Returns `true` if there are elements in the [PKeyList] or `false` if it is empty.
     */
    public fun isNotEmpty(): Boolean = _size != 0

    /**
     * Returns the last element in the [PKeyList] or throws a [NoSuchElementException] if
     * it [isEmpty].
     */
    public fun last(): PKey {
        if (isEmpty()) {
            throwNoSuchElementException("PKeyList is empty.")
        }
        return content[lastIndex]
    }

    /**
     * Returns the last element in the [PKeyList] for which [predicate] returns `true` or
     * throws [NoSuchElementException] if nothing matches.
     * @see indexOfLast
     */
    public inline fun last(predicate: (element: PKey) -> Boolean): PKey {
        contract { callsInPlace(predicate) }
        forEachReversed { item ->
            if (predicate(item)) {
                return item
            }
        }
        throw NoSuchElementException("PKeyList contains no element matching the predicate.")
    }

    /**
     * Returns the index of the last element in the [PKeyList] that is the same as
     * [element] or `-1` if no elements match.
     */
    public fun lastIndexOf(element: PKey): Int {
        forEachReversedIndexed { i, item ->
            if (item == element) {
                return i
            }
        }
        return -1
    }

    /**
     * Creates a String from the elements separated by [separator] and using [prefix] before
     * and [postfix] after, if supplied.
     *
     * When a non-negative value of [limit] is provided, a maximum of [limit] items are used
     * to generate the string. If the collection holds more than [limit] items, the string
     * is terminated with [truncated].
     */
    @JvmOverloads
    public fun joinToString(
        separator: CharSequence = ", ",
        prefix: CharSequence = "",
        postfix: CharSequence = "", // I know this should be suffix, but this is kotlin's name
        limit: Int = -1,
        truncated: CharSequence = "...",
    ): String = buildString {
        append(prefix)
        this@PKeyList.forEachIndexed { index, element ->
            if (index == limit) {
                append(truncated)
                return@buildString
            }
            if (index != 0) {
                append(separator)
            }
            append(element)
        }
        append(postfix)
    }

    /**
     * Creates a String from the elements separated by [separator] and using [prefix] before
     * and [postfix] after, if supplied. [transform] dictates how each element will be represented.
     *
     * When a non-negative value of [limit] is provided, a maximum of [limit] items are used
     * to generate the string. If the collection holds more than [limit] items, the string
     * is terminated with [truncated].
     */
    @JvmOverloads
    public inline fun joinToString(
        separator: CharSequence = ", ",
        prefix: CharSequence = "",
        postfix: CharSequence = "", // I know this should be suffix, but this is kotlin's name
        limit: Int = -1,
        truncated: CharSequence = "...",
        crossinline transform: (PKey) -> CharSequence
    ): String = buildString {
        append(prefix)
        this@PKeyList.forEachIndexed { index, element ->
            if (index == limit) {
                append(truncated)
                return@buildString
            }
            if (index != 0) {
                append(separator)
            }
            append(transform(element))
        }
        append(postfix)
    }

    /**
     * Returns a hash code based on the contents of the [PKeyList].
     */
    override fun hashCode(): Int {
        var hashCode = 0
        forEach { element ->
            hashCode += 31 * element.hashCode()
        }
        return hashCode
    }

    /**
     * Returns `true` if [other] is a [PKeyList] and the contents of this and [other] are the
     * same.
     */
    override fun equals(other: Any?): Boolean {
        if (other !is PKeyList || other._size != _size) {
            return false
        }
        val content = content
        val otherContent = other.content
        for (i in indices) {
            if (content[i] != otherContent[i]) {
                return false
            }
        }
        return true
    }

    /**
     * Returns a String representation of the list, surrounded by "[]" and each element
     * separated by ", ".
     */
    override fun toString(): String = joinToString(prefix = "[", postfix = "]")
}

/**
 * [MutablePKeyList] is a [MutableList]-like collection for [PKey] values.
 * It allows storing and retrieving the elements without boxing. Immutable
 * access is available through its base class [PKeyList], which has a [List]-like
 * interface.
 *
 * This implementation is not thread-safe: if multiple threads access this
 * container concurrently, and one or more threads modify the structure of
 * the list (insertion or removal for instance), the calling code must provide
 * the appropriate synchronization. It is also not safe to mutate during reentrancy --
 * in the middle of a [forEach], for example. However, concurrent reads are safe.
 *
 * @constructor Creates a [MutablePKeyList] with a [capacity] of `initialCapacity`.
 */
public class MutablePKeyList(
    initialCapacity: Int = 16
) : PKeyList(initialCapacity) {
    /**
     * Returns the total number of elements that can be held before the [MutablePKeyList] must
     * grow.
     *
     * @see ensureCapacity
     */
    public inline val capacity: Int
        get() = content.size

    /**
     * Adds [element] to the [MutablePKeyList] and returns `true`.
     */
    public fun add(element: PKey): Boolean {
        ensureCapacity(_size + 1)
        content[_size] = element
        _size++
        return true
    }

    /**
     * Adds [element] to the [MutablePKeyList] at the given [index], shifting over any
     * elements at [index] and after, if any.
     * @throws IndexOutOfBoundsException if [index] isn't between 0 and [size], inclusive
     */
    public fun add(@IntRange(from = 0) index: Int, element: PKey) {
        if (index !in 0.._size) {
            throwIndexOutOfBoundsException("Index $index must be in 0..$_size")
        }
        ensureCapacity(_size + 1)
        val content = content
        if (index != _size) {
            content.copyInto(
                destination = content,
                destinationOffset = index + 1,
                startIndex = index,
                endIndex = _size
            )
        }
        content[index] = element
        _size++
    }

    /**
     * Adds all [elements] to the [MutablePKeyList] at the given [index], shifting over any
     * elements at [index] and after, if any.
     * @return `true` if the [MutablePKeyList] was changed or `false` if [elements] was empty
     * @throws IndexOutOfBoundsException if [index] isn't between 0 and [size], inclusive.
     */
    public fun addAll(
        @IntRange(from = 0) index: Int,
        elements: PKeyArray
    ): Boolean {
        if (index !in 0.._size) {
            throwIndexOutOfBoundsException("Index $index must be in 0..$_size")
        }
        if (elements.isEmpty()) return false
        ensureCapacity(_size + elements.size)
        val content = content
        if (index != _size) {
            content.copyInto(
                destination = content,
                destinationOffset = index + elements.size,
                startIndex = index,
                endIndex = _size
            )
        }
        elements.copyInto(content, index)
        _size += elements.size
        return true
    }

    /**
     * Adds all [elements] to the [MutablePKeyList] at the given [index], shifting over any
     * elements at [index] and after, if any.
     * @return `true` if the [MutablePKeyList] was changed or `false` if [elements] was empty
     * @throws IndexOutOfBoundsException if [index] isn't between 0 and [size], inclusive
     */
    public fun addAll(
        @IntRange(from = 0) index: Int,
        elements: PKeyList
    ): Boolean {
        if (index !in 0.._size) {
            throwIndexOutOfBoundsException("Index $index must be in 0..$_size")
        }
        if (elements.isEmpty()) return false
        ensureCapacity(_size + elements._size)
        val content = content
        if (index != _size) {
            content.copyInto(
                destination = content,
                destinationOffset = index + elements._size,
                startIndex = index,
                endIndex = _size
            )
        }
        elements.content.copyInto(
            destination = content,
            destinationOffset = index,
            startIndex = 0,
            endIndex = elements._size
        )
        _size += elements._size
        return true
    }

    /**
     * Adds all [elements] to the end of the [MutablePKeyList] and returns `true` if the
     * [MutablePKeyList] was changed or `false` if [elements] was empty.
     */
    public fun addAll(elements: PKeyList): Boolean {
        return addAll(_size, elements)
    }

    /**
     * Adds all [elements] to the end of the [MutablePKeyList] and returns `true` if the
     * [MutablePKeyList] was changed or `false` if [elements] was empty.
     */
    public fun addAll(elements: PKeyArray): Boolean {
        return addAll(_size, elements)
    }

    /**
     * Adds all [elements] to the end of the [MutablePKeyList].
     */
    public operator fun plusAssign(elements: PKeyList) {
        addAll(_size, elements)
    }

    /**
     * Adds all [elements] to the end of the [MutablePKeyList].
     */
    public operator fun plusAssign(elements: PKeyArray) {
        addAll(_size, elements)
    }

    /**
     * Removes all elements in the [MutablePKeyList]. The storage isn't released.
     * @see trim
     */
    public fun clear() {
        _size = 0
    }

    /**
     * Reduces the internal storage. If [capacity] is greater than [minCapacity] and [size], the
     * internal storage is reduced to the maximum of [size] and [minCapacity].
     * @see ensureCapacity
     */
    public fun trim(minCapacity: Int = _size) {
        val minSize = maxOf(minCapacity, _size)
        if (capacity > minSize) {
            content = content.copyOf(minSize)
        }
    }

    /**
     * Ensures that there is enough space to store [capacity] elements in the [MutablePKeyList].
     * @see trim
     */
    public fun ensureCapacity(capacity: Int) {
        val oldContent = content
        if (oldContent.size < capacity) {
            val newSize = maxOf(capacity, oldContent.size * 3 / 2)
            content = oldContent.copyOf(newSize)
        }
    }

    /**
     * [add] [element] to the [MutablePKeyList].
     */
    public inline operator fun plusAssign(element: PKey) {
        add(element)
    }

    /**
     * [remove] [element] from the [MutablePKeyList]
     */
    public inline operator fun minusAssign(element: PKey) {
        remove(element)
    }

    /**
     * Removes [element] from the [MutablePKeyList]. If [element] was in the [MutablePKeyList]
     * and was removed, `true` will be returned, or `false` will be returned if the element
     * was not found.
     */
    public fun remove(element: PKey): Boolean {
        val index = indexOf(element)
        if (index >= 0) {
            removeAt(index)
            return true
        }
        return false
    }

    /**
     * Removes all [elements] from the [MutablePKeyList] and returns `true` if anything was removed.
     */
    public fun removeAll(elements: PKeyArray): Boolean {
        val initialSize = _size
        for (i in elements.indices) {
            remove(elements[i])
        }
        return initialSize != _size
    }

    /**
     * Removes all [elements] from the [MutablePKeyList] and returns `true` if anything was removed.
     */
    public fun removeAll(elements: PKeyList): Boolean {
        val initialSize = _size
        for (i in 0..elements.lastIndex) {
            remove(elements[i])
        }
        return initialSize != _size
    }

    /**
     * Removes all [elements] from the [MutablePKeyList].
     */
    public operator fun minusAssign(elements: PKeyArray) {
        elements.forEach { element ->
            remove(element)
        }
    }

    /**
     * Removes all [elements] from the [MutablePKeyList].
     */
    public operator fun minusAssign(elements: PKeyList) {
        elements.forEach { element ->
            remove(element)
        }
    }

    /**
     * Removes the element at the given [index] and returns it.
     * @throws IndexOutOfBoundsException if [index] isn't between 0 and [lastIndex], inclusive
     */
    public fun removeAt(@IntRange(from = 0) index: Int): PKey {
        if (index !in 0 until _size) {
            throwIndexOutOfBoundsException("Index $index must be in 0..$lastIndex")
        }
        val content = content
        val item = content[index]
        if (index != lastIndex) {
            content.copyInto(
                destination = content,
                destinationOffset = index,
                startIndex = index + 1,
                endIndex = _size
            )
        }
        _size--
        return item
    }

    /**
     * Removes items from index [start] (inclusive) to [end] (exclusive).
     * @throws IndexOutOfBoundsException if [start] or [end] isn't between 0 and [size], inclusive
     * @throws IllegalArgumentException if [start] is greater than [end]
     */
    public fun removeRange(
        @IntRange(from = 0) start: Int,
        @IntRange(from = 0) end: Int
    ) {
        if (start !in 0.._size || end !in 0.._size) {
            throwIndexOutOfBoundsException("Start ($start) and end ($end) must be in 0..$_size")
        }
        if (end < start) {
            throwIllegalArgumentException("Start ($start) is more than end ($end)")
        }
        if (end != start) {
            if (end < _size) {
                content.copyInto(
                    destination = content,
                    destinationOffset = start,
                    startIndex = end,
                    endIndex = _size
                )
            }
            _size -= (end - start)
        }
    }

    /**
     * Keeps only [elements] in the [MutablePKeyList] and removes all other values.
     * @return `true` if the [MutablePKeyList] has changed.
     */
    public fun retainAll(elements: PKeyArray): Boolean {
        val initialSize = _size
        val content = content
        for (i in lastIndex downTo 0) {
            val item = content[i]
            if (elements.indexOfFirst { it == item } < 0) {
                removeAt(i)
            }
        }
        return initialSize != _size
    }

    /**
     * Keeps only [elements] in the [MutablePKeyList] and removes all other values.
     * @return `true` if the [MutablePKeyList] has changed.
     */
    public fun retainAll(elements: PKeyList): Boolean {
        val initialSize = _size
        val content = content
        for (i in lastIndex downTo 0) {
            val item = content[i]
            if (item !in elements) {
                removeAt(i)
            }
        }
        return initialSize != _size
    }

    /**
     * Sets the value at [index] to [element].
     * @return the previous value set at [index]
     * @throws IndexOutOfBoundsException if [index] isn't between 0 and [lastIndex], inclusive
     */
    public operator fun set(
        @IntRange(from = 0) index: Int,
        element: PKey
    ): PKey {
        if (index !in 0 until _size) {
            throwIndexOutOfBoundsException("set index $index must be between 0 .. $lastIndex")
        }
        val content = content
        val old = content[index]
        content[index] = element
        return old
    }

    /**
     * Sorts the [MutablePKeyList] elements in ascending order.
     */
    public fun sort() {
        // TODO: remove a return after https://youtrack.jetbrains.com/issue/KT-70005 is fixed
        if (_size == 0) return
        content.sort(fromIndex = 0, toIndex = _size)
    }

    /**
     * Sorts the [MutablePKeyList] elements in descending order.
     */
    public fun sortDescending() {
        // TODO: remove a return after https://youtrack.jetbrains.com/issue/KT-70005 is fixed
        if (_size == 0) return
        content.sortDescending(fromIndex = 0, toIndex = _size)
    }
}

private val EmptyPKeyList: PKeyList = MutablePKeyList(0)

/**
 * @return a read-only [PKeyList] with nothing in it.
 */
public fun emptyPKeyList(): PKeyList = EmptyPKeyList

/**
 * @return a read-only [PKeyList] with nothing in it.
 */
public fun pKeyListOf(): PKeyList = EmptyPKeyList

/**
 * @return a new read-only [PKeyList] with [element1] as the only item in the list.
 */
public fun pKeyListOf(element1: PKey): PKeyList = mutablePKeyListOf(element1)

/**
 * @return a new read-only [PKeyList] with 2 elements, [element1] and [element2], in order.
 */
public fun pKeyListOf(element1: PKey, element2: PKey): PKeyList =
    mutablePKeyListOf(element1, element2)

/**
 * @return a new read-only [PKeyList] with 3 elements, [element1], [element2], and [element3],
 * in order.
 */
public fun pKeyListOf(element1: PKey, element2: PKey, element3: PKey): PKeyList =
    mutablePKeyListOf(element1, element2, element3)

/**
 * @return a new read-only [PKeyList] with [elements] in order.
 */
public fun pKeyListOf(vararg elements: PKey): PKeyList =
    MutablePKeyList(elements.size).apply { plusAssign(elements) }

/**
 * @return a new empty [MutablePKeyList] with the default capacity.
 */
public inline fun mutablePKeyListOf(): MutablePKeyList = MutablePKeyList()

/**
 * @return a new [MutablePKeyList] with [element1] as the only item in the list.
 */
public fun mutablePKeyListOf(element1: PKey): MutablePKeyList {
    val list = MutablePKeyList(1)
    list += element1
    return list
}

/**
 * @return a new [MutablePKeyList] with 2 elements, [element1] and [element2], in order.
 */
public fun mutablePKeyListOf(element1: PKey, element2: PKey): MutablePKeyList {
    val list = MutablePKeyList(2)
    list += element1
    list += element2
    return list
}

/**
 * @return a new [MutablePKeyList] with 3 elements, [element1], [element2], and [element3],
 * in order.
 */
public fun mutablePKeyListOf(element1: PKey, element2: PKey, element3: PKey): MutablePKeyList {
    val list = MutablePKeyList(3)
    list += element1
    list += element2
    list += element3
    return list
}

/**
 * @return a new [MutablePKeyList] with the given elements, in order.
 */
public inline fun mutablePKeyListOf(vararg elements: PKey): MutablePKeyList =
    MutablePKeyList(elements.size).apply { plusAssign(elements) }
