/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import androidx.build.BuildOnServerKt
import androidx.build.LibraryType
import androidx.build.SdkHelperKt
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile

import java.util.regex.Matcher
import java.util.regex.Pattern
import java.util.zip.ZipEntry
import java.util.zip.ZipFile

plugins {
    id("AndroidXPlugin")
    id("kotlin")
    id("com.github.johnrengelman.shadow")
}

configurations {
    /**
     * shadowed is used for dependencies which we jarjar into the library jar instead of adding it
     * as a pom dependency
     */
    shadowed
    // make sure shadowed dependencies show up as compileOnly so that normal compilation works
    compileOnly.extendsFrom(shadowed)
    // compiler tests run w/o shadowed classes so we should add those dependencies into test
    // configuration
    testCompile.extendsFrom(shadowed)
    // for downstream tests, provide a configuration that includes the shadow output + other
    // dependencies that are not shadowed
    shadowAndImplementation.extendsFrom(shadow)
    shadowAndImplementation.extendsFrom(implementation)
}

shadowJar {
    // set classifier to empty string so that it doesn't append anything to the jar.
    archiveClassifier = ""
    configurations = [project.configurations.shadowed]
    relocate("org.antlr", "androidx.room.jarjarred.org.antlr")
    relocate("org.stringtemplate", "androidx.room.jarjarred.org.stringtemplate")
}

jar {
    // set a classifier on this one so that the output does not clash with the output from
    // shadowJar task. We should never use this directly as it won't have the shadowed classes that
    // are necessary to run.
    archiveClassifier = "before-jarjar"
}

configurations {
    // replace the standard jar with the one built by 'shadowJar' in both api and runtime variants
    apiElements.outgoing.artifacts.clear()
    apiElements.outgoing.artifact(shadowJar) {
        builtBy shadowJar
    }
    runtimeElements.outgoing.artifacts.clear()
    runtimeElements.outgoing.artifact(shadowJar) {
        builtBy shadowJar
    }
}

androidx.configureAarAsJarForConfiguration("testImplementation")

dependencies {
    implementation(project(":room:room-common"))
    implementation(project(":room:room-migration"))
    implementation(project(":room:room-compiler-processing"))
    implementation(libs.kotlinStdlib)
    implementation(libs.autoCommon)
    implementation(libs.autoValueAnnotations)
    implementation(libs.javapoet)
    implementation(libs.kotlinPoet)
    implementation(libs.kotlinPoetJavaPoet)
    implementation(libs.kspApi)
    shadowed(libs.antlr4) {
        // antlr has dependencies on unrelated projects for its gui stuff, do not include them
        exclude group: "org.abego.treelayout"
        exclude group: "com.ibm.icu"
        exclude group: "org.glassfish"
    }
    implementation(libs.sqliteJdbc)
    implementation(libs.apacheCommonsCodec)
    implementation(libs.intellijAnnotations)
    testImplementation(libs.truth)
    testImplementation(project(":kruth:kruth"))
    testImplementation(libs.testParameterInjector)
    testImplementation(libs.autoValue) // to access the processor in tests
    testImplementation(libs.autoServiceAnnotations)
    testImplementation(libs.autoService) // to access the processor in tests
    testImplementation(projectOrArtifact(":paging:paging-common"))
    testImplementation(project(":room:room-compiler-processing-testing"))
    testImplementation(libs.junit)
    testImplementation(libs.jsr250)
    testImplementation(libs.mockitoCore4)
    testImplementation(libs.antlr4)
    testImplementation(libs.kotlinCompilerEmbeddable)
    testImplementation(SdkHelperKt.getSdkDependency(project))
    testImplementationAarAsJar(project(":room:room-runtime"))
    testImplementationAarAsJar(project(":sqlite:sqlite"))
    testImplementation(project(":internal-testutils-common"))
}

def generateAntlrTask = tasks.register("generateAntlrGrammar", GenerateAntlrGrammar) { task ->
    task.getSqliteFile().set(layout.projectDirectory.file("SQLite.g4"))
    task.getAntlrClasspath().from(configurations.compileClasspath)
    task.getOutputDirectory().set(layout.buildDirectory.dir("generated/antlr/grammar-gen/"))
}

sourceSets {
    main.java.srcDirs += generateAntlrTask.map { it.outputDirectory }
}

@CacheableTask
abstract class GenerateAntlrGrammar extends DefaultTask {
    @PathSensitive(PathSensitivity.NONE)
    @InputFile
    abstract RegularFileProperty getSqliteFile()

    @Classpath
    abstract ConfigurableFileCollection getAntlrClasspath()

    @OutputDirectory
    abstract DirectoryProperty getOutputDirectory()

    @Inject
    abstract ExecOperations getExecOperations()

    @Inject
    public GenerateAntlrGrammar() {
        description("Generates Antlr Grammar used by room")
        group("build")
    }

    @TaskAction
    void generateAntlrGrammar() {
        execOperations.javaexec {
            mainClass.set("org.antlr.v4.Tool")
            classpath = getAntlrClasspath()
            args getSqliteFile().asFile.get().absolutePath,
                 "-visitor",
                 "-o", new File(getOutputDirectory().asFile.get(), "androidx/room/parser").path,
                 "-package", "androidx.room.parser"
        }
    }
}

/**
 * Room compiler jarjars some dependencies. This task validates the published artifacts of room
 * compiler to ensure dependencies are properly jarjarred.
 */
abstract class CheckArtifactTask extends DefaultTask {
    @InputFiles
    abstract ConfigurableFileCollection getArtifactInputs()
    @InputFile
    abstract RegularFileProperty getPomFile()
    @OutputFile
    abstract RegularFileProperty getResult()
    /**
     * Checks the publish task's artifacts to make sure the classes.jar does include jarjarred
     * antlr classes.
     */
    void validatePublishTaskOutputs() {
        if (getArtifactInputs().files.isEmpty()) {
            throw new GradleException("Couldn't find the classes.jar for the room-compiler " +
                    "artifact. Ensure that publish is setup properly.")
        }
        getArtifactInputs().forEach {
            validateJarContents(it)
        }
    }

    /**
     * Traverses the given jar file, looks for the classes that should be jarjarred and validates
     * their location.
     */
    static void validateJarContents(File jarFile) {
        Boolean found = false
        ZipFile zip = new ZipFile(jarFile)
        try {
            for (Enumeration list = zip.entries(); list.hasMoreElements(); ) {
                String entry = ((ZipEntry) list.nextElement()).name
                if (!entry.endsWith(".class")) continue
                if (entry.contains("org/antlr")) {
                    found = true
                    if (!entry.contains("androidx/room/jarjarred/org/antlr")) {
                        throw new GradleException("Any Antlr class included in the Room Compiler's" +
                                " jar file should be moved into androidx/room/jarjarred.\n" +
                                "Looks like $entry has not been moved")
                    }
                }
                if (!entry.startsWith("androidx/room/")) {
                    throw new GradleException("Found a class that is not in androidx.room " +
                            "package: $entry")
                }
            }
        } finally {
            zip.close()
        }
        if (!found) {
            throw new GradleException("Couldn't find any Antlr classes in room-compiler artifact" +
                    ".\n Antlr is jarjarred into room-compiler so there should be some files")
        }
    }

    /**
     * Checks the generated pom file to ensure it does not depend on any jarjarred dependencies
     * but still depends on others.
     */
    void validatePomTaskOutputs() {
        File pom = getPomFile().asFile.get()
        if (!pom.canRead()) {
            throw new GradleException("Cannot find the pom file for room-compiler")
        }
        def pomContents = pom.newReader().text
        Pattern antlrDep = Pattern.compile("<dependency>\\s.*antlr(.*\\s)*</dependency>")
        Matcher matcher = antlrDep.matcher(pomContents)
        if (matcher.find()) {
            throw new GradleException("Room-compiler pom file should not depend on antlr.\n" +
                    "Pom Contents:\n $pomContents")
        }
        if(!pomContents.contains("<artifactId>kotlin-stdlib</artifactId>")) {
            throw new GradleException("room-compiler should depend on kotlin stdlib.\n" +
                    "Pom Contents:\n $pomContents")
        }
    }

    @TaskAction
    void validate() {
        getResult().asFile.get().write("fail\n")
        validatePublishTaskOutputs()
        validatePomTaskOutputs()
        // have a no-op output to make gradle happy w/ input/output checking.
        getResult().asFile.get().write("ok\n")
    }
}

def checkArtifactContentsTask = tasks.register("checkArtifact", CheckArtifactTask) { task ->
    task.getResult().set(layout.buildDirectory.file("checkArtifactOutput.txt"))
    def pomTask = (TaskProvider<GenerateMavenPom>) project.tasks.named("generatePomFileForMavenPublication")
    task.getPomFile().set(
            project.objects.fileProperty().fileProvider(
                    pomTask.map {  it.destination }
            )
    )
}

afterEvaluate {
    def publishTaskProvider = project.tasks.named("publishMavenPublicationToMavenRepository")
    checkArtifactContentsTask.configure { checkArtifactTask ->
        checkArtifactTask.getArtifactInputs().from {
            publishTaskProvider.map {
                ((PublishToMavenRepository) it).getPublication().artifacts.matching {
                    it.classifier == null
                }.collect {
                    it.file
                }
            }
        }
    }
}

// make sure we validate published artifacts on the build server.
BuildOnServerKt.addToBuildOnServer(project, checkArtifactContentsTask)

tasks.withType(KotlinCompile).configureEach {
    kotlinOptions {
        freeCompilerArgs += [
                "-opt-in=kotlin.contracts.ExperimentalContracts",
                "-opt-in=androidx.room.compiler.processing.ExperimentalProcessingApi",
                "-opt-in=com.squareup.kotlinpoet.javapoet.KotlinPoetJavaPoetPreview"
        ]
    }
}

tasks.withType(Test).configureEach {
    it.systemProperty("androidx.room.compiler.processing.strict", "true")
    it.maxParallelForks(5)
    if (project.providers.environmentVariable("GITHUB_ACTIONS").present) {
        // limit memory usage to avoid running out of memory in the docker container.
        it.maxHeapSize("512m")
    }
}

androidx {
    name = "Room Compiler"
    type = LibraryType.ANNOTATION_PROCESSOR
    inceptionYear = "2017"
    description = "Android Room annotation processor"
    license { // jarjared antlr library
        name = "BSD licence"
        url = "http://antlr.org/license.html"
    }
}
