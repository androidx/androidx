// Signature format: 4.0
package androidx.camera.core {

  @RequiresApi(21) public class AspectRatio {
    field public static final int RATIO_16_9 = 1; // 0x1
    field public static final int RATIO_4_3 = 0; // 0x0
    field public static final int RATIO_DEFAULT = -1; // 0xffffffff
  }

  @RequiresApi(21) public interface Camera {
    method public androidx.camera.core.CameraControl getCameraControl();
    method public androidx.camera.core.CameraInfo getCameraInfo();
  }

  @RequiresApi(21) public interface CameraControl {
    method public com.google.common.util.concurrent.ListenableFuture<java.lang.Void!> cancelFocusAndMetering();
    method public com.google.common.util.concurrent.ListenableFuture<java.lang.Void!> enableTorch(boolean);
    method public com.google.common.util.concurrent.ListenableFuture<java.lang.Integer!> setExposureCompensationIndex(int);
    method public com.google.common.util.concurrent.ListenableFuture<java.lang.Void!> setLinearZoom(@FloatRange(from=0.0f, to=1.0f) float);
    method public com.google.common.util.concurrent.ListenableFuture<java.lang.Void!> setZoomRatio(float);
    method public com.google.common.util.concurrent.ListenableFuture<androidx.camera.core.FocusMeteringResult!> startFocusAndMetering(androidx.camera.core.FocusMeteringAction);
  }

  public static final class CameraControl.OperationCanceledException extends java.lang.Exception {
  }

  @RequiresApi(21) public abstract class CameraEffect {
    ctor protected CameraEffect(int, java.util.concurrent.Executor, androidx.camera.core.ImageProcessor, androidx.core.util.Consumer<java.lang.Throwable!>);
    ctor protected CameraEffect(int, java.util.concurrent.Executor, androidx.camera.core.SurfaceProcessor, androidx.core.util.Consumer<java.lang.Throwable!>);
    method public androidx.core.util.Consumer<java.lang.Throwable!> getErrorListener();
    method public java.util.concurrent.Executor getExecutor();
    method public androidx.camera.core.SurfaceProcessor? getSurfaceProcessor();
    method public int getTargets();
    field public static final int IMAGE_CAPTURE = 4; // 0x4
    field public static final int PREVIEW = 1; // 0x1
    field public static final int VIDEO_CAPTURE = 2; // 0x2
  }

  @RequiresApi(21) public interface CameraFilter {
    method public java.util.List<androidx.camera.core.CameraInfo!> filter(java.util.List<androidx.camera.core.CameraInfo!>);
  }

  @RequiresApi(21) public interface CameraInfo {
    method public androidx.camera.core.CameraSelector getCameraSelector();
    method public androidx.lifecycle.LiveData<androidx.camera.core.CameraState!> getCameraState();
    method public androidx.camera.core.ExposureState getExposureState();
    method @FloatRange(from=0, fromInclusive=false) public default float getIntrinsicZoomRatio();
    method public default int getLensFacing();
    method public int getSensorRotationDegrees();
    method public int getSensorRotationDegrees(int);
    method public default java.util.Set<android.util.Range<java.lang.Integer!>!> getSupportedFrameRateRanges();
    method public androidx.lifecycle.LiveData<java.lang.Integer!> getTorchState();
    method public androidx.lifecycle.LiveData<androidx.camera.core.ZoomState!> getZoomState();
    method public boolean hasFlashUnit();
    method public default boolean isFocusMeteringSupported(androidx.camera.core.FocusMeteringAction);
    method @SuppressCompatibility @androidx.camera.core.ExperimentalZeroShutterLag public default boolean isZslSupported();
    method public static boolean mustPlayShutterSound();
    method public default java.util.Set<androidx.camera.core.DynamicRange!> querySupportedDynamicRanges(java.util.Set<androidx.camera.core.DynamicRange!>);
  }

  @RequiresApi(21) public final class CameraInfoUnavailableException extends java.lang.Exception {
  }

  @RequiresApi(21) public interface CameraProvider {
    method public java.util.List<androidx.camera.core.CameraInfo!> getAvailableCameraInfos();
    method public boolean hasCamera(androidx.camera.core.CameraSelector) throws androidx.camera.core.CameraInfoUnavailableException;
  }

  @RequiresApi(21) public final class CameraSelector {
    method public java.util.List<androidx.camera.core.CameraInfo!> filter(java.util.List<androidx.camera.core.CameraInfo!>);
    field public static final androidx.camera.core.CameraSelector DEFAULT_BACK_CAMERA;
    field public static final androidx.camera.core.CameraSelector DEFAULT_FRONT_CAMERA;
    field public static final int LENS_FACING_BACK = 1; // 0x1
    field @SuppressCompatibility @androidx.camera.core.ExperimentalLensFacing public static final int LENS_FACING_EXTERNAL = 2; // 0x2
    field public static final int LENS_FACING_FRONT = 0; // 0x0
    field public static final int LENS_FACING_UNKNOWN = -1; // 0xffffffff
  }

  public static final class CameraSelector.Builder {
    ctor public CameraSelector.Builder();
    method public androidx.camera.core.CameraSelector.Builder addCameraFilter(androidx.camera.core.CameraFilter);
    method public androidx.camera.core.CameraSelector build();
    method public androidx.camera.core.CameraSelector.Builder requireLensFacing(int);
  }

  @RequiresApi(21) @com.google.auto.value.AutoValue public abstract class CameraState {
    ctor public CameraState();
    method public static androidx.camera.core.CameraState create(androidx.camera.core.CameraState.Type);
    method public static androidx.camera.core.CameraState create(androidx.camera.core.CameraState.Type, androidx.camera.core.CameraState.StateError?);
    method public abstract androidx.camera.core.CameraState.StateError? getError();
    method public abstract androidx.camera.core.CameraState.Type getType();
    field public static final int ERROR_CAMERA_DISABLED = 5; // 0x5
    field public static final int ERROR_CAMERA_FATAL_ERROR = 6; // 0x6
    field public static final int ERROR_CAMERA_IN_USE = 2; // 0x2
    field public static final int ERROR_DO_NOT_DISTURB_MODE_ENABLED = 7; // 0x7
    field public static final int ERROR_MAX_CAMERAS_IN_USE = 1; // 0x1
    field public static final int ERROR_OTHER_RECOVERABLE_ERROR = 3; // 0x3
    field public static final int ERROR_STREAM_CONFIG = 4; // 0x4
  }

  public enum CameraState.ErrorType {
    enum_constant public static final androidx.camera.core.CameraState.ErrorType CRITICAL;
    enum_constant public static final androidx.camera.core.CameraState.ErrorType RECOVERABLE;
  }

  @com.google.auto.value.AutoValue public abstract static class CameraState.StateError {
    ctor public CameraState.StateError();
    method public static androidx.camera.core.CameraState.StateError create(int);
    method public static androidx.camera.core.CameraState.StateError create(int, Throwable?);
    method public abstract Throwable? getCause();
    method public abstract int getCode();
    method public androidx.camera.core.CameraState.ErrorType getType();
  }

  public enum CameraState.Type {
    enum_constant public static final androidx.camera.core.CameraState.Type CLOSED;
    enum_constant public static final androidx.camera.core.CameraState.Type CLOSING;
    enum_constant public static final androidx.camera.core.CameraState.Type OPEN;
    enum_constant public static final androidx.camera.core.CameraState.Type OPENING;
    enum_constant public static final androidx.camera.core.CameraState.Type PENDING_OPEN;
  }

  @RequiresApi(21) public class CameraUnavailableException extends java.lang.Exception {
    ctor public CameraUnavailableException(int);
    ctor public CameraUnavailableException(int, String?);
    ctor public CameraUnavailableException(int, String?, Throwable?);
    ctor public CameraUnavailableException(int, Throwable?);
    method public int getReason();
    field public static final int CAMERA_DISABLED = 1; // 0x1
    field public static final int CAMERA_DISCONNECTED = 2; // 0x2
    field public static final int CAMERA_ERROR = 3; // 0x3
    field public static final int CAMERA_IN_USE = 4; // 0x4
    field public static final int CAMERA_MAX_IN_USE = 5; // 0x5
    field public static final int CAMERA_UNAVAILABLE_DO_NOT_DISTURB = 6; // 0x6
    field public static final int CAMERA_UNKNOWN_ERROR = 0; // 0x0
  }

  @RequiresApi(21) public final class CameraXConfig {
    method public androidx.camera.core.CameraSelector? getAvailableCamerasLimiter(androidx.camera.core.CameraSelector?);
    method public java.util.concurrent.Executor? getCameraExecutor(java.util.concurrent.Executor?);
    method public long getCameraOpenRetryMaxTimeoutInMillisWhileResuming();
    method public int getMinimumLoggingLevel();
    method public android.os.Handler? getSchedulerHandler(android.os.Handler?);
  }

  public static final class CameraXConfig.Builder {
    method public androidx.camera.core.CameraXConfig build();
    method public static androidx.camera.core.CameraXConfig.Builder fromConfig(androidx.camera.core.CameraXConfig);
    method public androidx.camera.core.CameraXConfig.Builder setAvailableCamerasLimiter(androidx.camera.core.CameraSelector);
    method public androidx.camera.core.CameraXConfig.Builder setCameraExecutor(java.util.concurrent.Executor);
    method public androidx.camera.core.CameraXConfig.Builder setCameraOpenRetryMaxTimeoutInMillisWhileResuming(long);
    method public androidx.camera.core.CameraXConfig.Builder setMinimumLoggingLevel(@IntRange(from=android.util.Log.DEBUG, to=android.util.Log.ERROR) int);
    method public androidx.camera.core.CameraXConfig.Builder setSchedulerHandler(android.os.Handler);
  }

  public static interface CameraXConfig.Provider {
    method public androidx.camera.core.CameraXConfig getCameraXConfig();
  }

  @RequiresApi(21) public class ConcurrentCamera {
    ctor public ConcurrentCamera(java.util.List<androidx.camera.core.Camera!>);
    method public java.util.List<androidx.camera.core.Camera!> getCameras();
  }

  public static final class ConcurrentCamera.SingleCameraConfig {
    ctor public ConcurrentCamera.SingleCameraConfig(androidx.camera.core.CameraSelector, androidx.camera.core.UseCaseGroup, androidx.lifecycle.LifecycleOwner);
    method public androidx.camera.core.CameraSelector getCameraSelector();
    method public androidx.lifecycle.LifecycleOwner getLifecycleOwner();
    method public androidx.camera.core.UseCaseGroup getUseCaseGroup();
  }

  @RequiresApi(21) public final class DisplayOrientedMeteringPointFactory extends androidx.camera.core.MeteringPointFactory {
    ctor public DisplayOrientedMeteringPointFactory(android.view.Display, androidx.camera.core.CameraInfo, float, float);
  }

  @RequiresApi(21) public final class DynamicRange {
    ctor public DynamicRange(int, int);
    method public int getBitDepth();
    method public int getEncoding();
    field public static final int BIT_DEPTH_10_BIT = 10; // 0xa
    field public static final int BIT_DEPTH_8_BIT = 8; // 0x8
    field public static final int BIT_DEPTH_UNSPECIFIED = 0; // 0x0
    field public static final androidx.camera.core.DynamicRange DOLBY_VISION_10_BIT;
    field public static final androidx.camera.core.DynamicRange DOLBY_VISION_8_BIT;
    field public static final int ENCODING_DOLBY_VISION = 6; // 0x6
    field public static final int ENCODING_HDR10 = 4; // 0x4
    field public static final int ENCODING_HDR10_PLUS = 5; // 0x5
    field public static final int ENCODING_HDR_UNSPECIFIED = 2; // 0x2
    field public static final int ENCODING_HLG = 3; // 0x3
    field public static final int ENCODING_SDR = 1; // 0x1
    field public static final int ENCODING_UNSPECIFIED = 0; // 0x0
    field public static final androidx.camera.core.DynamicRange HDR10_10_BIT;
    field public static final androidx.camera.core.DynamicRange HDR10_PLUS_10_BIT;
    field public static final androidx.camera.core.DynamicRange HDR_UNSPECIFIED_10_BIT;
    field public static final androidx.camera.core.DynamicRange HLG_10_BIT;
    field public static final androidx.camera.core.DynamicRange SDR;
    field public static final androidx.camera.core.DynamicRange UNSPECIFIED;
  }

  @SuppressCompatibility @RequiresApi(21) @RequiresOptIn @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) public @interface ExperimentalGetImage {
  }

  @SuppressCompatibility @RequiresOptIn @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) public @interface ExperimentalLensFacing {
  }

  @SuppressCompatibility @RequiresOptIn @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) public @interface ExperimentalUseCaseApi {
  }

  @SuppressCompatibility @RequiresOptIn @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS) public @interface ExperimentalZeroShutterLag {
  }

  @RequiresApi(21) public interface ExposureState {
    method public int getExposureCompensationIndex();
    method public android.util.Range<java.lang.Integer!> getExposureCompensationRange();
    method public android.util.Rational getExposureCompensationStep();
    method public boolean isExposureCompensationSupported();
  }

  @RequiresApi(21) public interface ExtendableBuilder<T> {
    method public T build();
  }

  @RequiresApi(21) public final class FocusMeteringAction {
    method public long getAutoCancelDurationInMillis();
    method public java.util.List<androidx.camera.core.MeteringPoint!> getMeteringPointsAe();
    method public java.util.List<androidx.camera.core.MeteringPoint!> getMeteringPointsAf();
    method public java.util.List<androidx.camera.core.MeteringPoint!> getMeteringPointsAwb();
    method public boolean isAutoCancelEnabled();
    field public static final int FLAG_AE = 2; // 0x2
    field public static final int FLAG_AF = 1; // 0x1
    field public static final int FLAG_AWB = 4; // 0x4
  }

  public static class FocusMeteringAction.Builder {
    ctor public FocusMeteringAction.Builder(androidx.camera.core.MeteringPoint);
    ctor public FocusMeteringAction.Builder(androidx.camera.core.MeteringPoint, int);
    method public androidx.camera.core.FocusMeteringAction.Builder addPoint(androidx.camera.core.MeteringPoint);
    method public androidx.camera.core.FocusMeteringAction.Builder addPoint(androidx.camera.core.MeteringPoint, int);
    method public androidx.camera.core.FocusMeteringAction build();
    method public androidx.camera.core.FocusMeteringAction.Builder disableAutoCancel();
    method public androidx.camera.core.FocusMeteringAction.Builder setAutoCancelDuration(@IntRange(from=1) long, java.util.concurrent.TimeUnit);
  }

  @RequiresApi(21) public final class FocusMeteringResult {
    method public boolean isFocusSuccessful();
  }

  @RequiresApi(21) public final class ImageAnalysis extends androidx.camera.core.UseCase {
    method public void clearAnalyzer();
    method @SuppressCompatibility @androidx.camera.core.ExperimentalUseCaseApi public java.util.concurrent.Executor? getBackgroundExecutor();
    method public int getBackpressureStrategy();
    method public int getImageQueueDepth();
    method public int getOutputImageFormat();
    method public androidx.camera.core.ResolutionInfo? getResolutionInfo();
    method public androidx.camera.core.resolutionselector.ResolutionSelector? getResolutionSelector();
    method public int getTargetRotation();
    method public boolean isOutputImageRotationEnabled();
    method public void setAnalyzer(java.util.concurrent.Executor, androidx.camera.core.ImageAnalysis.Analyzer);
    method public void setTargetRotation(int);
    field public static final int COORDINATE_SYSTEM_ORIGINAL = 0; // 0x0
    field public static final int COORDINATE_SYSTEM_SENSOR = 2; // 0x2
    field public static final int OUTPUT_IMAGE_FORMAT_RGBA_8888 = 2; // 0x2
    field public static final int OUTPUT_IMAGE_FORMAT_YUV_420_888 = 1; // 0x1
    field public static final int STRATEGY_BLOCK_PRODUCER = 1; // 0x1
    field public static final int STRATEGY_KEEP_ONLY_LATEST = 0; // 0x0
  }

  public static interface ImageAnalysis.Analyzer {
    method public void analyze(androidx.camera.core.ImageProxy);
    method public default android.util.Size? getDefaultTargetResolution();
    method public default int getTargetCoordinateSystem();
    method public default void updateTransform(android.graphics.Matrix?);
  }

  public static final class ImageAnalysis.Builder implements androidx.camera.core.ExtendableBuilder<androidx.camera.core.ImageAnalysis> {
    ctor public ImageAnalysis.Builder();
    method public androidx.camera.core.ImageAnalysis build();
    method public androidx.camera.core.ImageAnalysis.Builder setBackgroundExecutor(java.util.concurrent.Executor);
    method public androidx.camera.core.ImageAnalysis.Builder setBackpressureStrategy(int);
    method public androidx.camera.core.ImageAnalysis.Builder setImageQueueDepth(int);
    method public androidx.camera.core.ImageAnalysis.Builder setOutputImageFormat(int);
    method @RequiresApi(23) public androidx.camera.core.ImageAnalysis.Builder setOutputImageRotationEnabled(boolean);
    method public androidx.camera.core.ImageAnalysis.Builder setResolutionSelector(androidx.camera.core.resolutionselector.ResolutionSelector);
    method @Deprecated public androidx.camera.core.ImageAnalysis.Builder setTargetAspectRatio(int);
    method public androidx.camera.core.ImageAnalysis.Builder setTargetName(String);
    method @Deprecated public androidx.camera.core.ImageAnalysis.Builder setTargetResolution(android.util.Size);
    method public androidx.camera.core.ImageAnalysis.Builder setTargetRotation(int);
  }

  @RequiresApi(21) public final class ImageCapture extends androidx.camera.core.UseCase {
    method public int getCaptureMode();
    method public int getFlashMode();
    method public static androidx.camera.core.ImageCaptureCapabilities getImageCaptureCapabilities(androidx.camera.core.CameraInfo);
    method @IntRange(from=1, to=100) public int getJpegQuality();
    method public androidx.camera.core.resolutionselector.ResolutionSelector? getPostviewResolutionSelector();
    method public androidx.camera.core.ImageCaptureLatencyEstimate getRealtimeCaptureLatencyEstimate();
    method public androidx.camera.core.ResolutionInfo? getResolutionInfo();
    method public androidx.camera.core.resolutionselector.ResolutionSelector? getResolutionSelector();
    method public androidx.camera.core.ImageCapture.ScreenFlash? getScreenFlash();
    method public int getTargetRotation();
    method public boolean isPostviewEnabled();
    method public void setCropAspectRatio(android.util.Rational);
    method public void setFlashMode(int);
    method public void setScreenFlash(androidx.camera.core.ImageCapture.ScreenFlash?);
    method public void setTargetRotation(int);
    method public void takePicture(androidx.camera.core.ImageCapture.OutputFileOptions, java.util.concurrent.Executor, androidx.camera.core.ImageCapture.OnImageSavedCallback);
    method public void takePicture(java.util.concurrent.Executor, androidx.camera.core.ImageCapture.OnImageCapturedCallback);
    field public static final int CAPTURE_MODE_MAXIMIZE_QUALITY = 0; // 0x0
    field public static final int CAPTURE_MODE_MINIMIZE_LATENCY = 1; // 0x1
    field @SuppressCompatibility @androidx.camera.core.ExperimentalZeroShutterLag public static final int CAPTURE_MODE_ZERO_SHUTTER_LAG = 2; // 0x2
    field public static final int ERROR_CAMERA_CLOSED = 3; // 0x3
    field public static final int ERROR_CAPTURE_FAILED = 2; // 0x2
    field public static final int ERROR_FILE_IO = 1; // 0x1
    field public static final int ERROR_INVALID_CAMERA = 4; // 0x4
    field public static final int ERROR_UNKNOWN = 0; // 0x0
    field public static final int FLASH_MODE_AUTO = 0; // 0x0
    field public static final int FLASH_MODE_OFF = 2; // 0x2
    field public static final int FLASH_MODE_ON = 1; // 0x1
    field public static final int FLASH_MODE_SCREEN = 3; // 0x3
  }

  public static final class ImageCapture.Builder implements androidx.camera.core.ExtendableBuilder<androidx.camera.core.ImageCapture> {
    ctor public ImageCapture.Builder();
    method public androidx.camera.core.ImageCapture build();
    method public androidx.camera.core.ImageCapture.Builder setCaptureMode(int);
    method public androidx.camera.core.ImageCapture.Builder setFlashMode(int);
    method public androidx.camera.core.ImageCapture.Builder setIoExecutor(java.util.concurrent.Executor);
    method public androidx.camera.core.ImageCapture.Builder setJpegQuality(@IntRange(from=1, to=100) int);
    method public androidx.camera.core.ImageCapture.Builder setPostviewEnabled(boolean);
    method public androidx.camera.core.ImageCapture.Builder setPostviewResolutionSelector(androidx.camera.core.resolutionselector.ResolutionSelector);
    method public androidx.camera.core.ImageCapture.Builder setResolutionSelector(androidx.camera.core.resolutionselector.ResolutionSelector);
    method public androidx.camera.core.ImageCapture.Builder setScreenFlash(androidx.camera.core.ImageCapture.ScreenFlash);
    method @Deprecated public androidx.camera.core.ImageCapture.Builder setTargetAspectRatio(int);
    method public androidx.camera.core.ImageCapture.Builder setTargetName(String);
    method @Deprecated public androidx.camera.core.ImageCapture.Builder setTargetResolution(android.util.Size);
    method public androidx.camera.core.ImageCapture.Builder setTargetRotation(int);
  }

  public static final class ImageCapture.Metadata {
    ctor public ImageCapture.Metadata();
    method public android.location.Location? getLocation();
    method public boolean isReversedHorizontal();
    method public boolean isReversedVertical();
    method public void setLocation(android.location.Location?);
    method public void setReversedHorizontal(boolean);
    method public void setReversedVertical(boolean);
  }

  public abstract static class ImageCapture.OnImageCapturedCallback {
    ctor public ImageCapture.OnImageCapturedCallback();
    method public void onCaptureProcessProgressed(int);
    method public void onCaptureStarted();
    method public void onCaptureSuccess(androidx.camera.core.ImageProxy);
    method public void onError(androidx.camera.core.ImageCaptureException);
    method public void onPostviewBitmapAvailable(android.graphics.Bitmap);
  }

  public static interface ImageCapture.OnImageSavedCallback {
    method public default void onCaptureProcessProgressed(int);
    method public default void onCaptureStarted();
    method public void onError(androidx.camera.core.ImageCaptureException);
    method public void onImageSaved(androidx.camera.core.ImageCapture.OutputFileResults);
    method public default void onPostviewBitmapAvailable(android.graphics.Bitmap);
  }

  public static final class ImageCapture.OutputFileOptions {
  }

  public static final class ImageCapture.OutputFileOptions.Builder {
    ctor public ImageCapture.OutputFileOptions.Builder(android.content.ContentResolver, android.net.Uri, android.content.ContentValues);
    ctor public ImageCapture.OutputFileOptions.Builder(java.io.File);
    ctor public ImageCapture.OutputFileOptions.Builder(java.io.OutputStream);
    method public androidx.camera.core.ImageCapture.OutputFileOptions build();
    method public androidx.camera.core.ImageCapture.OutputFileOptions.Builder setMetadata(androidx.camera.core.ImageCapture.Metadata);
  }

  public static class ImageCapture.OutputFileResults {
    method public android.net.Uri? getSavedUri();
  }

  public static interface ImageCapture.ScreenFlash {
    method @UiThread public void apply(long, androidx.camera.core.ImageCapture.ScreenFlashListener);
    method @UiThread public void clear();
  }

  public static interface ImageCapture.ScreenFlashListener {
    method public void onCompleted();
  }

  public interface ImageCaptureCapabilities {
    method public boolean isCaptureProcessProgressSupported();
    method public boolean isPostviewSupported();
  }

  @RequiresApi(21) public class ImageCaptureException extends java.lang.Exception {
    ctor public ImageCaptureException(int, String, Throwable?);
    method public int getImageCaptureError();
  }

  @RequiresApi(21) public class ImageCaptureLatencyEstimate {
    method public long getCaptureLatencyMillis();
    method public long getProcessingLatencyMillis();
    method public long getTotalCaptureLatencyMillis();
    field public static final long UNDEFINED_CAPTURE_LATENCY = -1L; // 0xffffffffffffffffL
    field public static final androidx.camera.core.ImageCaptureLatencyEstimate UNDEFINED_IMAGE_CAPTURE_LATENCY;
    field public static final long UNDEFINED_PROCESSING_LATENCY = -1L; // 0xffffffffffffffffL
  }

  @RequiresApi(21) public interface ImageInfo {
    method public int getRotationDegrees();
    method public default android.graphics.Matrix getSensorToBufferTransformMatrix();
    method public long getTimestamp();
  }

  public interface ImageProcessor {
    method public androidx.camera.core.ImageProcessor.Response process(androidx.camera.core.ImageProcessor.Request) throws androidx.camera.core.ProcessingException;
  }

  public static interface ImageProcessor.Request {
    method public androidx.camera.core.ImageProxy getInputImage();
    method public int getOutputFormat();
  }

  public static interface ImageProcessor.Response {
    method public androidx.camera.core.ImageProxy getOutputImage();
  }

  @RequiresApi(21) public interface ImageProxy extends java.lang.AutoCloseable {
    method public void close();
    method public android.graphics.Rect getCropRect();
    method public int getFormat();
    method public int getHeight();
    method @SuppressCompatibility @androidx.camera.core.ExperimentalGetImage public android.media.Image? getImage();
    method public androidx.camera.core.ImageInfo getImageInfo();
    method public androidx.camera.core.ImageProxy.PlaneProxy![] getPlanes();
    method public int getWidth();
    method public void setCropRect(android.graphics.Rect?);
    method public default android.graphics.Bitmap toBitmap();
  }

  public static interface ImageProxy.PlaneProxy {
    method public java.nio.ByteBuffer getBuffer();
    method public int getPixelStride();
    method public int getRowStride();
  }

  @RequiresApi(21) public class InitializationException extends java.lang.Exception {
    ctor public InitializationException(String?);
    ctor public InitializationException(String?, Throwable?);
    ctor public InitializationException(Throwable?);
  }

  @RequiresApi(21) public class MeteringPoint {
    method public float getSize();
  }

  @RequiresApi(21) public abstract class MeteringPointFactory {
    method public final androidx.camera.core.MeteringPoint createPoint(float, float);
    method public final androidx.camera.core.MeteringPoint createPoint(float, float, float);
    method public static float getDefaultPointSize();
  }

  @RequiresApi(21) public class MirrorMode {
    field public static final int MIRROR_MODE_OFF = 0; // 0x0
    field public static final int MIRROR_MODE_ON = 1; // 0x1
    field public static final int MIRROR_MODE_ON_FRONT_ONLY = 2; // 0x2
  }

  @RequiresApi(21) public final class Preview extends androidx.camera.core.UseCase {
    method public androidx.camera.core.DynamicRange getDynamicRange();
    method public static androidx.camera.core.PreviewCapabilities getPreviewCapabilities(androidx.camera.core.CameraInfo);
    method public androidx.camera.core.ResolutionInfo? getResolutionInfo();
    method public androidx.camera.core.resolutionselector.ResolutionSelector? getResolutionSelector();
    method public android.util.Range<java.lang.Integer!> getTargetFrameRate();
    method public int getTargetRotation();
    method public boolean isPreviewStabilizationEnabled();
    method @UiThread public void setSurfaceProvider(androidx.camera.core.Preview.SurfaceProvider?);
    method @UiThread public void setSurfaceProvider(java.util.concurrent.Executor, androidx.camera.core.Preview.SurfaceProvider?);
    method public void setTargetRotation(int);
  }

  public static final class Preview.Builder implements androidx.camera.core.ExtendableBuilder<androidx.camera.core.Preview> {
    ctor public Preview.Builder();
    method public androidx.camera.core.Preview build();
    method public androidx.camera.core.Preview.Builder setDynamicRange(androidx.camera.core.DynamicRange);
    method public androidx.camera.core.Preview.Builder setPreviewStabilizationEnabled(boolean);
    method public androidx.camera.core.Preview.Builder setResolutionSelector(androidx.camera.core.resolutionselector.ResolutionSelector);
    method @Deprecated public androidx.camera.core.Preview.Builder setTargetAspectRatio(int);
    method public androidx.camera.core.Preview.Builder setTargetFrameRate(android.util.Range<java.lang.Integer!>);
    method public androidx.camera.core.Preview.Builder setTargetName(String);
    method @Deprecated public androidx.camera.core.Preview.Builder setTargetResolution(android.util.Size);
    method public androidx.camera.core.Preview.Builder setTargetRotation(int);
  }

  public static interface Preview.SurfaceProvider {
    method public void onSurfaceRequested(androidx.camera.core.SurfaceRequest);
  }

  @RequiresApi(21) public interface PreviewCapabilities {
    method public boolean isStabilizationSupported();
  }

  public class ProcessingException extends java.lang.Exception {
    ctor public ProcessingException();
  }

  @RequiresApi(21) public class ResolutionInfo {
    ctor public ResolutionInfo(android.util.Size, android.graphics.Rect, int);
    method public android.graphics.Rect getCropRect();
    method public android.util.Size getResolution();
    method public int getRotationDegrees();
  }

  @RequiresApi(21) public class SurfaceOrientedMeteringPointFactory extends androidx.camera.core.MeteringPointFactory {
    ctor public SurfaceOrientedMeteringPointFactory(float, float);
    ctor public SurfaceOrientedMeteringPointFactory(float, float, androidx.camera.core.UseCase);
  }

  public interface SurfaceOutput extends java.io.Closeable {
    method public void close();
    method public default android.graphics.Matrix getSensorToBufferTransform();
    method public android.util.Size getSize();
    method public android.view.Surface getSurface(java.util.concurrent.Executor, androidx.core.util.Consumer<androidx.camera.core.SurfaceOutput.Event!>);
    method public int getTargets();
    method public void updateTransformMatrix(float[], float[]);
  }

  @com.google.auto.value.AutoValue public abstract static class SurfaceOutput.Event {
    method public abstract int getEventCode();
    method public abstract androidx.camera.core.SurfaceOutput getSurfaceOutput();
    field public static final int EVENT_REQUEST_CLOSE = 0; // 0x0
  }

  public interface SurfaceProcessor {
    method public void onInputSurface(androidx.camera.core.SurfaceRequest) throws androidx.camera.core.ProcessingException;
    method public void onOutputSurface(androidx.camera.core.SurfaceOutput) throws androidx.camera.core.ProcessingException;
  }

  @RequiresApi(21) public final class SurfaceRequest {
    method public void addRequestCancellationListener(java.util.concurrent.Executor, Runnable);
    method public void clearTransformationInfoListener();
    method public androidx.camera.core.DynamicRange getDynamicRange();
    method public android.util.Size getResolution();
    method public boolean invalidate();
    method public void provideSurface(android.view.Surface, java.util.concurrent.Executor, androidx.core.util.Consumer<androidx.camera.core.SurfaceRequest.Result!>);
    method public void setTransformationInfoListener(java.util.concurrent.Executor, androidx.camera.core.SurfaceRequest.TransformationInfoListener);
    method public boolean willNotProvideSurface();
  }

  @com.google.auto.value.AutoValue public abstract static class SurfaceRequest.Result {
    method public abstract int getResultCode();
    method public abstract android.view.Surface getSurface();
    field public static final int RESULT_INVALID_SURFACE = 2; // 0x2
    field public static final int RESULT_REQUEST_CANCELLED = 1; // 0x1
    field public static final int RESULT_SURFACE_ALREADY_PROVIDED = 3; // 0x3
    field public static final int RESULT_SURFACE_USED_SUCCESSFULLY = 0; // 0x0
    field public static final int RESULT_WILL_NOT_PROVIDE_SURFACE = 4; // 0x4
  }

  @com.google.auto.value.AutoValue public abstract static class SurfaceRequest.TransformationInfo {
    method public abstract android.graphics.Rect getCropRect();
    method public abstract int getRotationDegrees();
    method public abstract android.graphics.Matrix getSensorToBufferTransform();
    method public abstract boolean hasCameraTransform();
    method public abstract boolean isMirroring();
  }

  public static interface SurfaceRequest.TransformationInfoListener {
    method public void onTransformationInfoUpdate(androidx.camera.core.SurfaceRequest.TransformationInfo);
  }

  @RequiresApi(21) public class TorchState {
    field public static final int OFF = 0; // 0x0
    field public static final int ON = 1; // 0x1
  }

  @RequiresApi(21) public abstract class UseCase {
    method public static int snapToSurfaceRotation(@IntRange(from=0, to=359) int);
  }

  @RequiresApi(21) public final class UseCaseGroup {
    method public java.util.List<androidx.camera.core.CameraEffect!> getEffects();
    method public java.util.List<androidx.camera.core.UseCase!> getUseCases();
    method public androidx.camera.core.ViewPort? getViewPort();
  }

  public static final class UseCaseGroup.Builder {
    ctor public UseCaseGroup.Builder();
    method public androidx.camera.core.UseCaseGroup.Builder addEffect(androidx.camera.core.CameraEffect);
    method public androidx.camera.core.UseCaseGroup.Builder addUseCase(androidx.camera.core.UseCase);
    method public androidx.camera.core.UseCaseGroup build();
    method public androidx.camera.core.UseCaseGroup.Builder setViewPort(androidx.camera.core.ViewPort);
  }

  @RequiresApi(21) public final class ViewPort {
    method public android.util.Rational getAspectRatio();
    method public int getLayoutDirection();
    method public int getRotation();
    method public int getScaleType();
    field public static final int FILL_CENTER = 1; // 0x1
    field public static final int FILL_END = 2; // 0x2
    field public static final int FILL_START = 0; // 0x0
    field public static final int FIT = 3; // 0x3
  }

  public static final class ViewPort.Builder {
    ctor public ViewPort.Builder(android.util.Rational, int);
    method public androidx.camera.core.ViewPort build();
    method public androidx.camera.core.ViewPort.Builder setLayoutDirection(int);
    method public androidx.camera.core.ViewPort.Builder setScaleType(int);
  }

  @RequiresApi(21) public interface ZoomState {
    method public float getLinearZoom();
    method public float getMaxZoomRatio();
    method public float getMinZoomRatio();
    method public float getZoomRatio();
  }

}

package androidx.camera.core.resolutionselector {

  @RequiresApi(21) public final class AspectRatioStrategy {
    ctor public AspectRatioStrategy(int, int);
    method public int getFallbackRule();
    method public int getPreferredAspectRatio();
    field public static final int FALLBACK_RULE_AUTO = 1; // 0x1
    field public static final int FALLBACK_RULE_NONE = 0; // 0x0
    field public static final androidx.camera.core.resolutionselector.AspectRatioStrategy RATIO_16_9_FALLBACK_AUTO_STRATEGY;
    field public static final androidx.camera.core.resolutionselector.AspectRatioStrategy RATIO_4_3_FALLBACK_AUTO_STRATEGY;
  }

  @RequiresApi(21) public interface ResolutionFilter {
    method public java.util.List<android.util.Size!> filter(java.util.List<android.util.Size!>, int);
  }

  @RequiresApi(21) public final class ResolutionSelector {
    method public int getAllowedResolutionMode();
    method public androidx.camera.core.resolutionselector.AspectRatioStrategy getAspectRatioStrategy();
    method public androidx.camera.core.resolutionselector.ResolutionFilter? getResolutionFilter();
    method public androidx.camera.core.resolutionselector.ResolutionStrategy? getResolutionStrategy();
    field public static final int PREFER_CAPTURE_RATE_OVER_HIGHER_RESOLUTION = 0; // 0x0
    field public static final int PREFER_HIGHER_RESOLUTION_OVER_CAPTURE_RATE = 1; // 0x1
  }

  public static final class ResolutionSelector.Builder {
    ctor public ResolutionSelector.Builder();
    method public androidx.camera.core.resolutionselector.ResolutionSelector build();
    method public androidx.camera.core.resolutionselector.ResolutionSelector.Builder setAllowedResolutionMode(int);
    method public androidx.camera.core.resolutionselector.ResolutionSelector.Builder setAspectRatioStrategy(androidx.camera.core.resolutionselector.AspectRatioStrategy);
    method public androidx.camera.core.resolutionselector.ResolutionSelector.Builder setResolutionFilter(androidx.camera.core.resolutionselector.ResolutionFilter);
    method public androidx.camera.core.resolutionselector.ResolutionSelector.Builder setResolutionStrategy(androidx.camera.core.resolutionselector.ResolutionStrategy);
  }

  @RequiresApi(21) public final class ResolutionStrategy {
    ctor public ResolutionStrategy(android.util.Size, int);
    method public android.util.Size? getBoundSize();
    method public int getFallbackRule();
    field public static final int FALLBACK_RULE_CLOSEST_HIGHER = 2; // 0x2
    field public static final int FALLBACK_RULE_CLOSEST_HIGHER_THEN_LOWER = 1; // 0x1
    field public static final int FALLBACK_RULE_CLOSEST_LOWER = 4; // 0x4
    field public static final int FALLBACK_RULE_CLOSEST_LOWER_THEN_HIGHER = 3; // 0x3
    field public static final int FALLBACK_RULE_NONE = 0; // 0x0
    field public static final androidx.camera.core.resolutionselector.ResolutionStrategy HIGHEST_AVAILABLE_STRATEGY;
  }

}

