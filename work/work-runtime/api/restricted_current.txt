// Signature format: 4.0
package androidx.work {

  public final class ArrayCreatingInputMerger extends androidx.work.InputMerger {
    ctor public ArrayCreatingInputMerger();
    method public androidx.work.Data merge(java.util.List<androidx.work.Data> inputs);
  }

  public enum BackoffPolicy {
    enum_constant public static final androidx.work.BackoffPolicy EXPONENTIAL;
    enum_constant public static final androidx.work.BackoffPolicy LINEAR;
  }

  public interface Clock {
    method public long currentTimeMillis();
  }

  public final class Configuration {
    method public androidx.work.Clock getClock();
    method public int getContentUriTriggerWorkersLimit();
    method public String? getDefaultProcessName();
    method public java.util.concurrent.Executor getExecutor();
    method public androidx.core.util.Consumer<java.lang.Throwable>? getInitializationExceptionHandler();
    method public androidx.work.InputMergerFactory getInputMergerFactory();
    method public int getMaxJobSchedulerId();
    method public int getMinJobSchedulerId();
    method public androidx.work.RunnableScheduler getRunnableScheduler();
    method public androidx.core.util.Consumer<java.lang.Throwable>? getSchedulingExceptionHandler();
    method public java.util.concurrent.Executor getTaskExecutor();
    method public kotlin.coroutines.CoroutineContext getWorkerCoroutineContext();
    method public androidx.core.util.Consumer<androidx.work.WorkerExceptionInfo>? getWorkerExecutionExceptionHandler();
    method public androidx.work.WorkerFactory getWorkerFactory();
    method public androidx.core.util.Consumer<androidx.work.WorkerExceptionInfo>? getWorkerInitializationExceptionHandler();
    method @SuppressCompatibility @androidx.work.ExperimentalConfigurationApi public boolean isMarkingJobsAsImportantWhileForeground();
    property public final androidx.work.Clock clock;
    property public final int contentUriTriggerWorkersLimit;
    property public final String? defaultProcessName;
    property public final java.util.concurrent.Executor executor;
    property public final androidx.core.util.Consumer<java.lang.Throwable>? initializationExceptionHandler;
    property public final androidx.work.InputMergerFactory inputMergerFactory;
    property @SuppressCompatibility @androidx.work.ExperimentalConfigurationApi public final boolean isMarkingJobsAsImportantWhileForeground;
    property public final int maxJobSchedulerId;
    property public final int minJobSchedulerId;
    property public final androidx.work.RunnableScheduler runnableScheduler;
    property public final androidx.core.util.Consumer<java.lang.Throwable>? schedulingExceptionHandler;
    property public final java.util.concurrent.Executor taskExecutor;
    property public final kotlin.coroutines.CoroutineContext workerCoroutineContext;
    property public final androidx.core.util.Consumer<androidx.work.WorkerExceptionInfo>? workerExecutionExceptionHandler;
    property public final androidx.work.WorkerFactory workerFactory;
    property public final androidx.core.util.Consumer<androidx.work.WorkerExceptionInfo>? workerInitializationExceptionHandler;
    field public static final androidx.work.Configuration.Companion Companion;
    field public static final int MIN_SCHEDULER_LIMIT = 20; // 0x14
  }

  public static final class Configuration.Builder {
    ctor public Configuration.Builder();
    method public androidx.work.Configuration build();
    method public androidx.work.Configuration.Builder setClock(androidx.work.Clock clock);
    method public androidx.work.Configuration.Builder setContentUriTriggerWorkersLimit(int contentUriTriggerWorkersLimit);
    method public androidx.work.Configuration.Builder setDefaultProcessName(String processName);
    method public androidx.work.Configuration.Builder setExecutor(java.util.concurrent.Executor executor);
    method public androidx.work.Configuration.Builder setInitializationExceptionHandler(androidx.core.util.Consumer<java.lang.Throwable> exceptionHandler);
    method public androidx.work.Configuration.Builder setInputMergerFactory(androidx.work.InputMergerFactory inputMergerFactory);
    method public androidx.work.Configuration.Builder setJobSchedulerJobIdRange(int minJobSchedulerId, int maxJobSchedulerId);
    method @SuppressCompatibility @androidx.work.ExperimentalConfigurationApi public androidx.work.Configuration.Builder setMarkingJobsAsImportantWhileForeground(boolean markAsImportant);
    method public androidx.work.Configuration.Builder setMaxSchedulerLimit(int maxSchedulerLimit);
    method public androidx.work.Configuration.Builder setMinimumLoggingLevel(int loggingLevel);
    method public androidx.work.Configuration.Builder setRunnableScheduler(androidx.work.RunnableScheduler runnableScheduler);
    method public androidx.work.Configuration.Builder setSchedulingExceptionHandler(androidx.core.util.Consumer<java.lang.Throwable> schedulingExceptionHandler);
    method public androidx.work.Configuration.Builder setTaskExecutor(java.util.concurrent.Executor taskExecutor);
    method public androidx.work.Configuration.Builder setWorkerCoroutineContext(kotlin.coroutines.CoroutineContext context);
    method public androidx.work.Configuration.Builder setWorkerExecutionExceptionHandler(androidx.core.util.Consumer<androidx.work.WorkerExceptionInfo> workerExceptionHandler);
    method public androidx.work.Configuration.Builder setWorkerFactory(androidx.work.WorkerFactory workerFactory);
    method public androidx.work.Configuration.Builder setWorkerInitializationExceptionHandler(androidx.core.util.Consumer<androidx.work.WorkerExceptionInfo> workerExceptionHandler);
  }

  public static final class Configuration.Companion {
  }

  public static interface Configuration.Provider {
    method public androidx.work.Configuration getWorkManagerConfiguration();
    property public abstract androidx.work.Configuration workManagerConfiguration;
  }

  public final class Constraints {
    ctor public Constraints(androidx.work.Constraints other);
    ctor @androidx.room.Ignore public Constraints(optional androidx.work.NetworkType requiredNetworkType, optional boolean requiresCharging, optional boolean requiresBatteryNotLow, optional boolean requiresStorageNotLow);
    ctor @RequiresApi(23) @androidx.room.Ignore public Constraints(optional androidx.work.NetworkType requiredNetworkType, optional boolean requiresCharging, optional boolean requiresDeviceIdle, optional boolean requiresBatteryNotLow, optional boolean requiresStorageNotLow);
    ctor @RequiresApi(24) @androidx.room.Ignore public Constraints(optional androidx.work.NetworkType requiredNetworkType, optional boolean requiresCharging, optional boolean requiresDeviceIdle, optional boolean requiresBatteryNotLow, optional boolean requiresStorageNotLow, optional long contentTriggerUpdateDelayMillis, optional long contentTriggerMaxDelayMillis, optional java.util.Set<androidx.work.Constraints.ContentUriTrigger> contentUriTriggers);
    method @RequiresApi(24) public long getContentTriggerMaxDelayMillis();
    method @RequiresApi(24) public long getContentTriggerUpdateDelayMillis();
    method @RequiresApi(24) public java.util.Set<androidx.work.Constraints.ContentUriTrigger> getContentUriTriggers();
    method @RequiresApi(21) public android.net.NetworkRequest? getRequiredNetworkRequest();
    method public androidx.work.NetworkType getRequiredNetworkType();
    method public boolean requiresBatteryNotLow();
    method public boolean requiresCharging();
    method @RequiresApi(23) public boolean requiresDeviceIdle();
    method public boolean requiresStorageNotLow();
    property @RequiresApi(24) public final long contentTriggerMaxDelayMillis;
    property @RequiresApi(24) public final long contentTriggerUpdateDelayMillis;
    property @RequiresApi(24) public final java.util.Set<androidx.work.Constraints.ContentUriTrigger> contentUriTriggers;
    property @RequiresApi(21) public final android.net.NetworkRequest? requiredNetworkRequest;
    property public final androidx.work.NetworkType requiredNetworkType;
    field public static final androidx.work.Constraints.Companion Companion;
    field public static final androidx.work.Constraints NONE;
  }

  public static final class Constraints.Builder {
    ctor public Constraints.Builder();
    method @RequiresApi(24) public androidx.work.Constraints.Builder addContentUriTrigger(android.net.Uri uri, boolean triggerForDescendants);
    method public androidx.work.Constraints build();
    method @RequiresApi(21) public androidx.work.Constraints.Builder setRequiredNetworkRequest(android.net.NetworkRequest networkRequest, androidx.work.NetworkType networkType);
    method public androidx.work.Constraints.Builder setRequiredNetworkType(androidx.work.NetworkType networkType);
    method public androidx.work.Constraints.Builder setRequiresBatteryNotLow(boolean requiresBatteryNotLow);
    method public androidx.work.Constraints.Builder setRequiresCharging(boolean requiresCharging);
    method @RequiresApi(23) public androidx.work.Constraints.Builder setRequiresDeviceIdle(boolean requiresDeviceIdle);
    method public androidx.work.Constraints.Builder setRequiresStorageNotLow(boolean requiresStorageNotLow);
    method @RequiresApi(26) public androidx.work.Constraints.Builder setTriggerContentMaxDelay(java.time.Duration duration);
    method @RequiresApi(24) public androidx.work.Constraints.Builder setTriggerContentMaxDelay(long duration, java.util.concurrent.TimeUnit timeUnit);
    method @RequiresApi(26) public androidx.work.Constraints.Builder setTriggerContentUpdateDelay(java.time.Duration duration);
    method @RequiresApi(24) public androidx.work.Constraints.Builder setTriggerContentUpdateDelay(long duration, java.util.concurrent.TimeUnit timeUnit);
  }

  public static final class Constraints.Companion {
  }

  public static final class Constraints.ContentUriTrigger {
    ctor public Constraints.ContentUriTrigger(android.net.Uri uri, boolean isTriggeredForDescendants);
    method public android.net.Uri getUri();
    method public boolean isTriggeredForDescendants();
    property public final boolean isTriggeredForDescendants;
    property public final android.net.Uri uri;
  }

  public abstract class CoroutineWorker extends androidx.work.ListenableWorker {
    ctor public CoroutineWorker(android.content.Context appContext, androidx.work.WorkerParameters params);
    method public abstract suspend Object? doWork(kotlin.coroutines.Continuation<? super androidx.work.ListenableWorker.Result>);
    method @Deprecated public kotlinx.coroutines.CoroutineDispatcher getCoroutineContext();
    method public suspend Object? getForegroundInfo(kotlin.coroutines.Continuation<? super androidx.work.ForegroundInfo>);
    method public final com.google.common.util.concurrent.ListenableFuture<androidx.work.ForegroundInfo> getForegroundInfoAsync();
    method public final void onStopped();
    method public final suspend Object? setForeground(androidx.work.ForegroundInfo foregroundInfo, kotlin.coroutines.Continuation<? super kotlin.Unit>);
    method public final suspend Object? setProgress(androidx.work.Data data, kotlin.coroutines.Continuation<? super kotlin.Unit>);
    method public final com.google.common.util.concurrent.ListenableFuture<androidx.work.ListenableWorker.Result> startWork();
    property @Deprecated public kotlinx.coroutines.CoroutineDispatcher coroutineContext;
  }

  public final class Data {
    ctor public Data(androidx.work.Data other);
    method @androidx.room.TypeConverter public static androidx.work.Data fromByteArray(byte[] bytes);
    method public boolean getBoolean(String key, boolean defaultValue);
    method public boolean[]? getBooleanArray(String key);
    method public byte getByte(String key, byte defaultValue);
    method public byte[]? getByteArray(String key);
    method public double getDouble(String key, double defaultValue);
    method public double[]? getDoubleArray(String key);
    method public float getFloat(String key, float defaultValue);
    method public float[]? getFloatArray(String key);
    method public int getInt(String key, int defaultValue);
    method public int[]? getIntArray(String key);
    method public java.util.Map<java.lang.String,java.lang.Object?> getKeyValueMap();
    method public long getLong(String key, long defaultValue);
    method public long[]? getLongArray(String key);
    method public String? getString(String key);
    method public String[]? getStringArray(String key);
    method public <T> boolean hasKeyWithValueOfType(String key, Class<T> klass);
    method public byte[] toByteArray();
    property public final java.util.Map<java.lang.String,java.lang.Object?> keyValueMap;
    field public static final androidx.work.Data.Companion Companion;
    field public static final androidx.work.Data EMPTY;
    field public static final int MAX_DATA_BYTES = 10240; // 0x2800
  }

  public static final class Data.Builder {
    ctor public Data.Builder();
    method public androidx.work.Data build();
    method public androidx.work.Data.Builder putAll(androidx.work.Data data);
    method public androidx.work.Data.Builder putAll(java.util.Map<java.lang.String,? extends java.lang.Object?> values);
    method public androidx.work.Data.Builder putBoolean(String key, boolean value);
    method public androidx.work.Data.Builder putBooleanArray(String key, boolean[] value);
    method public androidx.work.Data.Builder putByte(String key, byte value);
    method public androidx.work.Data.Builder putByteArray(String key, byte[] value);
    method public androidx.work.Data.Builder putDouble(String key, double value);
    method public androidx.work.Data.Builder putDoubleArray(String key, double[] value);
    method public androidx.work.Data.Builder putFloat(String key, float value);
    method public androidx.work.Data.Builder putFloatArray(String key, float[] value);
    method public androidx.work.Data.Builder putInt(String key, int value);
    method public androidx.work.Data.Builder putIntArray(String key, int[] value);
    method public androidx.work.Data.Builder putLong(String key, long value);
    method public androidx.work.Data.Builder putLongArray(String key, long[] value);
    method public androidx.work.Data.Builder putString(String key, String? value);
    method public androidx.work.Data.Builder putStringArray(String key, String?[] value);
  }

  public static final class Data.Companion {
    method @androidx.room.TypeConverter public androidx.work.Data fromByteArray(byte[] bytes);
  }

  public final class DataKt {
    method public static inline <reified T> boolean hasKeyWithValueOfType(androidx.work.Data, String key);
    method public static inline androidx.work.Data workDataOf(kotlin.Pair<java.lang.String,? extends java.lang.Object?>... pairs);
  }

  public class DelegatingWorkerFactory extends androidx.work.WorkerFactory {
    ctor public DelegatingWorkerFactory();
    method public final void addFactory(androidx.work.WorkerFactory workerFactory);
    method public final androidx.work.ListenableWorker? createWorker(android.content.Context appContext, String workerClassName, androidx.work.WorkerParameters workerParameters);
  }

  public enum ExistingPeriodicWorkPolicy {
    enum_constant public static final androidx.work.ExistingPeriodicWorkPolicy CANCEL_AND_REENQUEUE;
    enum_constant public static final androidx.work.ExistingPeriodicWorkPolicy KEEP;
    enum_constant @Deprecated public static final androidx.work.ExistingPeriodicWorkPolicy REPLACE;
    enum_constant public static final androidx.work.ExistingPeriodicWorkPolicy UPDATE;
  }

  public enum ExistingWorkPolicy {
    enum_constant public static final androidx.work.ExistingWorkPolicy APPEND;
    enum_constant public static final androidx.work.ExistingWorkPolicy APPEND_OR_REPLACE;
    enum_constant public static final androidx.work.ExistingWorkPolicy KEEP;
    enum_constant public static final androidx.work.ExistingWorkPolicy REPLACE;
  }

  @SuppressCompatibility @kotlin.RequiresOptIn(level=kotlin.RequiresOptIn.Level.WARNING) @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.BINARY) @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.FUNCTION, kotlin.annotation.AnnotationTarget.PROPERTY, kotlin.annotation.AnnotationTarget.PROPERTY_GETTER, kotlin.annotation.AnnotationTarget.CLASS}) public @interface ExperimentalConfigurationApi {
  }

  public final class ForegroundInfo {
    ctor public ForegroundInfo(int, android.app.Notification);
    ctor public ForegroundInfo(int, android.app.Notification, int);
    method public int getForegroundServiceType();
    method public android.app.Notification getNotification();
    method public int getNotificationId();
  }

  public interface ForegroundUpdater {
    method public com.google.common.util.concurrent.ListenableFuture<java.lang.Void!> setForegroundAsync(android.content.Context, java.util.UUID, androidx.work.ForegroundInfo);
  }

  public abstract class InputMerger {
    ctor public InputMerger();
    method public abstract androidx.work.Data merge(java.util.List<androidx.work.Data> inputs);
  }

  public abstract class InputMergerFactory {
    ctor public InputMergerFactory();
    method public abstract androidx.work.InputMerger? createInputMerger(String className);
  }

  public abstract class ListenableWorker {
    ctor public ListenableWorker(android.content.Context, androidx.work.WorkerParameters);
    method public final android.content.Context getApplicationContext();
    method public com.google.common.util.concurrent.ListenableFuture<androidx.work.ForegroundInfo!> getForegroundInfoAsync();
    method public final java.util.UUID getId();
    method public final androidx.work.Data getInputData();
    method @RequiresApi(28) public final android.net.Network? getNetwork();
    method @IntRange(from=0) public final int getRunAttemptCount();
    method @RequiresApi(31) public final int getStopReason();
    method public final java.util.Set<java.lang.String!> getTags();
    method @RequiresApi(24) public final java.util.List<java.lang.String!> getTriggeredContentAuthorities();
    method @RequiresApi(24) public final java.util.List<android.net.Uri!> getTriggeredContentUris();
    method public final boolean isStopped();
    method public void onStopped();
    method public final com.google.common.util.concurrent.ListenableFuture<java.lang.Void!> setForegroundAsync(androidx.work.ForegroundInfo);
    method public com.google.common.util.concurrent.ListenableFuture<java.lang.Void!> setProgressAsync(androidx.work.Data);
    method @MainThread public abstract com.google.common.util.concurrent.ListenableFuture<androidx.work.ListenableWorker.Result!> startWork();
  }

  public abstract static class ListenableWorker.Result {
    method public static androidx.work.ListenableWorker.Result failure();
    method public static androidx.work.ListenableWorker.Result failure(androidx.work.Data);
    method public abstract androidx.work.Data getOutputData();
    method public static androidx.work.ListenableWorker.Result retry();
    method public static androidx.work.ListenableWorker.Result success();
    method public static androidx.work.ListenableWorker.Result success(androidx.work.Data);
  }

  public enum NetworkType {
    enum_constant public static final androidx.work.NetworkType CONNECTED;
    enum_constant public static final androidx.work.NetworkType METERED;
    enum_constant public static final androidx.work.NetworkType NOT_REQUIRED;
    enum_constant public static final androidx.work.NetworkType NOT_ROAMING;
    enum_constant @RequiresApi(30) public static final androidx.work.NetworkType TEMPORARILY_UNMETERED;
    enum_constant public static final androidx.work.NetworkType UNMETERED;
  }

  public final class OneTimeWorkRequest extends androidx.work.WorkRequest {
    method public static androidx.work.OneTimeWorkRequest from(Class<? extends androidx.work.ListenableWorker> workerClass);
    method public static java.util.List<androidx.work.OneTimeWorkRequest> from(java.util.List<? extends java.lang.Class<? extends androidx.work.ListenableWorker>> workerClasses);
    field public static final androidx.work.OneTimeWorkRequest.Companion Companion;
  }

  public static final class OneTimeWorkRequest.Builder extends androidx.work.WorkRequest.Builder<androidx.work.OneTimeWorkRequest.Builder,androidx.work.OneTimeWorkRequest> {
    ctor public OneTimeWorkRequest.Builder(Class<? extends androidx.work.ListenableWorker> workerClass);
    ctor public OneTimeWorkRequest.Builder(kotlin.reflect.KClass<? extends androidx.work.ListenableWorker> workerClass);
    method public androidx.work.OneTimeWorkRequest.Builder setInputMerger(Class<? extends androidx.work.InputMerger> inputMerger);
  }

  public static final class OneTimeWorkRequest.Companion {
    method public androidx.work.OneTimeWorkRequest from(Class<? extends androidx.work.ListenableWorker> workerClass);
    method public java.util.List<androidx.work.OneTimeWorkRequest> from(java.util.List<? extends java.lang.Class<? extends androidx.work.ListenableWorker>> workerClasses);
  }

  public final class OneTimeWorkRequestKt {
    method public static inline <reified W extends androidx.work.ListenableWorker> androidx.work.OneTimeWorkRequest.Builder OneTimeWorkRequestBuilder();
    method public static inline androidx.work.OneTimeWorkRequest.Builder setInputMerger(androidx.work.OneTimeWorkRequest.Builder, kotlin.reflect.KClass<? extends androidx.work.InputMerger> inputMerger);
  }

  public interface Operation {
    method public com.google.common.util.concurrent.ListenableFuture<androidx.work.Operation.State.SUCCESS!> getResult();
    method public androidx.lifecycle.LiveData<androidx.work.Operation.State!> getState();
  }

  public abstract static class Operation.State {
  }

  public static final class Operation.State.FAILURE extends androidx.work.Operation.State {
    ctor public Operation.State.FAILURE(Throwable);
    method public Throwable getThrowable();
  }

  public static final class Operation.State.IN_PROGRESS extends androidx.work.Operation.State {
  }

  public static final class Operation.State.SUCCESS extends androidx.work.Operation.State {
  }

  public final class OperationKt {
    method public static suspend inline Object? await(androidx.work.Operation, kotlin.coroutines.Continuation<? super androidx.work.Operation.State.SUCCESS>);
  }

  public enum OutOfQuotaPolicy {
    enum_constant public static final androidx.work.OutOfQuotaPolicy DROP_WORK_REQUEST;
    enum_constant public static final androidx.work.OutOfQuotaPolicy RUN_AS_NON_EXPEDITED_WORK_REQUEST;
  }

  public final class OverwritingInputMerger extends androidx.work.InputMerger {
    ctor public OverwritingInputMerger();
    method public androidx.work.Data merge(java.util.List<androidx.work.Data> inputs);
  }

  public final class PeriodicWorkRequest extends androidx.work.WorkRequest {
    field public static final androidx.work.PeriodicWorkRequest.Companion Companion;
    field public static final long MIN_PERIODIC_FLEX_MILLIS = 300000L; // 0x493e0L
    field public static final long MIN_PERIODIC_INTERVAL_MILLIS = 900000L; // 0xdbba0L
  }

  public static final class PeriodicWorkRequest.Builder extends androidx.work.WorkRequest.Builder<androidx.work.PeriodicWorkRequest.Builder,androidx.work.PeriodicWorkRequest> {
    ctor @RequiresApi(26) public PeriodicWorkRequest.Builder(Class<? extends androidx.work.ListenableWorker> workerClass, java.time.Duration repeatInterval);
    ctor @RequiresApi(26) public PeriodicWorkRequest.Builder(Class<? extends androidx.work.ListenableWorker?> workerClass, java.time.Duration repeatInterval, java.time.Duration flexInterval);
    ctor public PeriodicWorkRequest.Builder(Class<? extends androidx.work.ListenableWorker?> workerClass, long repeatInterval, java.util.concurrent.TimeUnit repeatIntervalTimeUnit);
    ctor public PeriodicWorkRequest.Builder(Class<? extends androidx.work.ListenableWorker?> workerClass, long repeatInterval, java.util.concurrent.TimeUnit repeatIntervalTimeUnit, long flexInterval, java.util.concurrent.TimeUnit flexIntervalTimeUnit);
    ctor @RequiresApi(26) public PeriodicWorkRequest.Builder(kotlin.reflect.KClass<? extends androidx.work.ListenableWorker> workerClass, java.time.Duration repeatInterval);
    ctor @RequiresApi(26) public PeriodicWorkRequest.Builder(kotlin.reflect.KClass<? extends androidx.work.ListenableWorker> workerClass, java.time.Duration repeatInterval, java.time.Duration flexInterval);
    ctor public PeriodicWorkRequest.Builder(kotlin.reflect.KClass<? extends androidx.work.ListenableWorker> workerClass, long repeatInterval, java.util.concurrent.TimeUnit repeatIntervalTimeUnit);
    ctor public PeriodicWorkRequest.Builder(kotlin.reflect.KClass<? extends androidx.work.ListenableWorker> workerClass, long repeatInterval, java.util.concurrent.TimeUnit repeatIntervalTimeUnit, long flexInterval, java.util.concurrent.TimeUnit flexIntervalTimeUnit);
    method public androidx.work.PeriodicWorkRequest.Builder clearNextScheduleTimeOverride();
    method public androidx.work.PeriodicWorkRequest.Builder setNextScheduleTimeOverride(long nextScheduleTimeOverrideMillis);
  }

  public static final class PeriodicWorkRequest.Companion {
  }

  public final class PeriodicWorkRequestKt {
    method @RequiresApi(26) public static inline <reified W extends androidx.work.ListenableWorker> androidx.work.PeriodicWorkRequest.Builder PeriodicWorkRequestBuilder(java.time.Duration repeatInterval);
    method @RequiresApi(26) public static inline <reified W extends androidx.work.ListenableWorker> androidx.work.PeriodicWorkRequest.Builder PeriodicWorkRequestBuilder(java.time.Duration repeatInterval, java.time.Duration flexTimeInterval);
    method public static inline <reified W extends androidx.work.ListenableWorker> androidx.work.PeriodicWorkRequest.Builder PeriodicWorkRequestBuilder(long repeatInterval, java.util.concurrent.TimeUnit repeatIntervalTimeUnit);
    method public static inline <reified W extends androidx.work.ListenableWorker> androidx.work.PeriodicWorkRequest.Builder PeriodicWorkRequestBuilder(long repeatInterval, java.util.concurrent.TimeUnit repeatIntervalTimeUnit, long flexTimeInterval, java.util.concurrent.TimeUnit flexTimeIntervalUnit);
  }

  public interface ProgressUpdater {
    method public com.google.common.util.concurrent.ListenableFuture<java.lang.Void!> updateProgress(android.content.Context, java.util.UUID, androidx.work.Data);
  }

  public interface RunnableScheduler {
    method public void cancel(Runnable);
    method public void scheduleWithDelay(@IntRange(from=0) long, Runnable);
  }

  public abstract class WorkContinuation {
    ctor public WorkContinuation();
    method public static androidx.work.WorkContinuation combine(java.util.List<androidx.work.WorkContinuation!>);
    method public abstract androidx.work.Operation enqueue();
    method public abstract com.google.common.util.concurrent.ListenableFuture<java.util.List<androidx.work.WorkInfo!>!> getWorkInfos();
    method public abstract androidx.lifecycle.LiveData<java.util.List<androidx.work.WorkInfo!>!> getWorkInfosLiveData();
    method public final androidx.work.WorkContinuation then(androidx.work.OneTimeWorkRequest);
    method public abstract androidx.work.WorkContinuation then(java.util.List<androidx.work.OneTimeWorkRequest!>);
  }

  public final class WorkInfo {
    ctor public WorkInfo(java.util.UUID id, androidx.work.WorkInfo.State state, java.util.Set<java.lang.String> tags);
    ctor public WorkInfo(java.util.UUID id, androidx.work.WorkInfo.State state, java.util.Set<java.lang.String> tags, optional androidx.work.Data outputData);
    ctor public WorkInfo(java.util.UUID id, androidx.work.WorkInfo.State state, java.util.Set<java.lang.String> tags, optional androidx.work.Data outputData, optional androidx.work.Data progress);
    ctor public WorkInfo(java.util.UUID id, androidx.work.WorkInfo.State state, java.util.Set<java.lang.String> tags, optional androidx.work.Data outputData, optional androidx.work.Data progress, optional int runAttemptCount);
    ctor public WorkInfo(java.util.UUID id, androidx.work.WorkInfo.State state, java.util.Set<java.lang.String> tags, optional androidx.work.Data outputData, optional androidx.work.Data progress, optional int runAttemptCount, optional int generation);
    ctor public WorkInfo(java.util.UUID id, androidx.work.WorkInfo.State state, java.util.Set<java.lang.String> tags, optional androidx.work.Data outputData, optional androidx.work.Data progress, optional int runAttemptCount, optional int generation, optional androidx.work.Constraints constraints);
    ctor public WorkInfo(java.util.UUID id, androidx.work.WorkInfo.State state, java.util.Set<java.lang.String> tags, optional androidx.work.Data outputData, optional androidx.work.Data progress, optional int runAttemptCount, optional int generation, optional androidx.work.Constraints constraints, optional long initialDelayMillis);
    ctor public WorkInfo(java.util.UUID id, androidx.work.WorkInfo.State state, java.util.Set<java.lang.String> tags, optional androidx.work.Data outputData, optional androidx.work.Data progress, optional int runAttemptCount, optional int generation, optional androidx.work.Constraints constraints, optional long initialDelayMillis, optional androidx.work.WorkInfo.PeriodicityInfo? periodicityInfo);
    ctor public WorkInfo(java.util.UUID id, androidx.work.WorkInfo.State state, java.util.Set<java.lang.String> tags, optional androidx.work.Data outputData, optional androidx.work.Data progress, optional int runAttemptCount, optional int generation, optional androidx.work.Constraints constraints, optional long initialDelayMillis, optional androidx.work.WorkInfo.PeriodicityInfo? periodicityInfo, optional long nextScheduleTimeMillis);
    ctor public WorkInfo(java.util.UUID id, androidx.work.WorkInfo.State state, java.util.Set<java.lang.String> tags, optional androidx.work.Data outputData, optional androidx.work.Data progress, optional int runAttemptCount, optional int generation, optional androidx.work.Constraints constraints, optional long initialDelayMillis, optional androidx.work.WorkInfo.PeriodicityInfo? periodicityInfo, optional long nextScheduleTimeMillis, optional int stopReason);
    method public androidx.work.Constraints getConstraints();
    method public int getGeneration();
    method public java.util.UUID getId();
    method public long getInitialDelayMillis();
    method public long getNextScheduleTimeMillis();
    method public androidx.work.Data getOutputData();
    method public androidx.work.WorkInfo.PeriodicityInfo? getPeriodicityInfo();
    method public androidx.work.Data getProgress();
    method @IntRange(from=0L) public int getRunAttemptCount();
    method public androidx.work.WorkInfo.State getState();
    method @RequiresApi(31) public int getStopReason();
    method public java.util.Set<java.lang.String> getTags();
    property public final androidx.work.Constraints constraints;
    property public final int generation;
    property public final java.util.UUID id;
    property public final long initialDelayMillis;
    property public final long nextScheduleTimeMillis;
    property public final androidx.work.Data outputData;
    property public final androidx.work.WorkInfo.PeriodicityInfo? periodicityInfo;
    property public final androidx.work.Data progress;
    property @IntRange(from=0L) public final int runAttemptCount;
    property public final androidx.work.WorkInfo.State state;
    property @RequiresApi(31) public final int stopReason;
    property public final java.util.Set<java.lang.String> tags;
    field public static final androidx.work.WorkInfo.Companion Companion;
    field public static final int STOP_REASON_APP_STANDBY = 12; // 0xc
    field public static final int STOP_REASON_BACKGROUND_RESTRICTION = 11; // 0xb
    field public static final int STOP_REASON_CANCELLED_BY_APP = 1; // 0x1
    field public static final int STOP_REASON_CONSTRAINT_BATTERY_NOT_LOW = 5; // 0x5
    field public static final int STOP_REASON_CONSTRAINT_CHARGING = 6; // 0x6
    field public static final int STOP_REASON_CONSTRAINT_CONNECTIVITY = 7; // 0x7
    field public static final int STOP_REASON_CONSTRAINT_DEVICE_IDLE = 8; // 0x8
    field public static final int STOP_REASON_CONSTRAINT_STORAGE_NOT_LOW = 9; // 0x9
    field public static final int STOP_REASON_DEVICE_STATE = 4; // 0x4
    field public static final int STOP_REASON_ESTIMATED_APP_LAUNCH_TIME_CHANGED = 15; // 0xf
    field public static final int STOP_REASON_FOREGROUND_SERVICE_TIMEOUT = -128; // 0xffffff80
    field public static final int STOP_REASON_NOT_STOPPED = -256; // 0xffffff00
    field public static final int STOP_REASON_PREEMPT = 2; // 0x2
    field public static final int STOP_REASON_QUOTA = 10; // 0xa
    field public static final int STOP_REASON_SYSTEM_PROCESSING = 14; // 0xe
    field public static final int STOP_REASON_TIMEOUT = 3; // 0x3
    field public static final int STOP_REASON_UNKNOWN = -512; // 0xfffffe00
    field public static final int STOP_REASON_USER = 13; // 0xd
  }

  public static final class WorkInfo.Companion {
  }

  public static final class WorkInfo.PeriodicityInfo {
    ctor public WorkInfo.PeriodicityInfo(long repeatIntervalMillis, long flexIntervalMillis);
    method public long getFlexIntervalMillis();
    method public long getRepeatIntervalMillis();
    property public final long flexIntervalMillis;
    property public final long repeatIntervalMillis;
  }

  public enum WorkInfo.State {
    method public boolean isFinished();
    property public final boolean isFinished;
    enum_constant public static final androidx.work.WorkInfo.State BLOCKED;
    enum_constant public static final androidx.work.WorkInfo.State CANCELLED;
    enum_constant public static final androidx.work.WorkInfo.State ENQUEUED;
    enum_constant public static final androidx.work.WorkInfo.State FAILED;
    enum_constant public static final androidx.work.WorkInfo.State RUNNING;
    enum_constant public static final androidx.work.WorkInfo.State SUCCEEDED;
  }

  public abstract class WorkManager {
    method public final androidx.work.WorkContinuation beginUniqueWork(String uniqueWorkName, androidx.work.ExistingWorkPolicy existingWorkPolicy, androidx.work.OneTimeWorkRequest request);
    method public abstract androidx.work.WorkContinuation beginUniqueWork(String uniqueWorkName, androidx.work.ExistingWorkPolicy existingWorkPolicy, java.util.List<androidx.work.OneTimeWorkRequest> requests);
    method public final androidx.work.WorkContinuation beginWith(androidx.work.OneTimeWorkRequest request);
    method public abstract androidx.work.WorkContinuation beginWith(java.util.List<androidx.work.OneTimeWorkRequest> requests);
    method public abstract androidx.work.Operation cancelAllWork();
    method public abstract androidx.work.Operation cancelAllWorkByTag(String tag);
    method public abstract androidx.work.Operation cancelUniqueWork(String uniqueWorkName);
    method public abstract androidx.work.Operation cancelWorkById(java.util.UUID id);
    method public abstract android.app.PendingIntent createCancelPendingIntent(java.util.UUID id);
    method public final androidx.work.Operation enqueue(androidx.work.WorkRequest request);
    method public abstract androidx.work.Operation enqueue(java.util.List<? extends androidx.work.WorkRequest> requests);
    method public abstract androidx.work.Operation enqueueUniquePeriodicWork(String uniqueWorkName, androidx.work.ExistingPeriodicWorkPolicy existingPeriodicWorkPolicy, androidx.work.PeriodicWorkRequest request);
    method public androidx.work.Operation enqueueUniqueWork(String uniqueWorkName, androidx.work.ExistingWorkPolicy existingWorkPolicy, androidx.work.OneTimeWorkRequest request);
    method public abstract androidx.work.Operation enqueueUniqueWork(String uniqueWorkName, androidx.work.ExistingWorkPolicy existingWorkPolicy, java.util.List<androidx.work.OneTimeWorkRequest> requests);
    method public abstract androidx.work.Configuration getConfiguration();
    method @Deprecated public static androidx.work.WorkManager getInstance();
    method public static androidx.work.WorkManager getInstance(android.content.Context context);
    method public abstract com.google.common.util.concurrent.ListenableFuture<java.lang.Long> getLastCancelAllTimeMillis();
    method public abstract androidx.lifecycle.LiveData<java.lang.Long> getLastCancelAllTimeMillisLiveData();
    method public abstract com.google.common.util.concurrent.ListenableFuture<androidx.work.WorkInfo?> getWorkInfoById(java.util.UUID id);
    method public abstract kotlinx.coroutines.flow.Flow<androidx.work.WorkInfo?> getWorkInfoByIdFlow(java.util.UUID id);
    method public abstract androidx.lifecycle.LiveData<androidx.work.WorkInfo?> getWorkInfoByIdLiveData(java.util.UUID id);
    method public abstract com.google.common.util.concurrent.ListenableFuture<java.util.List<androidx.work.WorkInfo>> getWorkInfos(androidx.work.WorkQuery workQuery);
    method public abstract com.google.common.util.concurrent.ListenableFuture<java.util.List<androidx.work.WorkInfo>> getWorkInfosByTag(String tag);
    method public abstract kotlinx.coroutines.flow.Flow<java.util.List<androidx.work.WorkInfo>> getWorkInfosByTagFlow(String tag);
    method public abstract androidx.lifecycle.LiveData<java.util.List<androidx.work.WorkInfo>> getWorkInfosByTagLiveData(String tag);
    method public abstract kotlinx.coroutines.flow.Flow<java.util.List<androidx.work.WorkInfo>> getWorkInfosFlow(androidx.work.WorkQuery workQuery);
    method public abstract com.google.common.util.concurrent.ListenableFuture<java.util.List<androidx.work.WorkInfo>> getWorkInfosForUniqueWork(String uniqueWorkName);
    method public abstract kotlinx.coroutines.flow.Flow<java.util.List<androidx.work.WorkInfo>> getWorkInfosForUniqueWorkFlow(String uniqueWorkName);
    method public abstract androidx.lifecycle.LiveData<java.util.List<androidx.work.WorkInfo>> getWorkInfosForUniqueWorkLiveData(String uniqueWorkName);
    method public abstract androidx.lifecycle.LiveData<java.util.List<androidx.work.WorkInfo>> getWorkInfosLiveData(androidx.work.WorkQuery workQuery);
    method public static void initialize(android.content.Context context, androidx.work.Configuration configuration);
    method public static boolean isInitialized();
    method public abstract androidx.work.Operation pruneWork();
    method public abstract com.google.common.util.concurrent.ListenableFuture<androidx.work.WorkManager.UpdateResult> updateWork(androidx.work.WorkRequest request);
    property public abstract androidx.work.Configuration configuration;
    field public static final androidx.work.WorkManager.Companion Companion;
  }

  public static final class WorkManager.Companion {
    method @Deprecated public androidx.work.WorkManager getInstance();
    method public androidx.work.WorkManager getInstance(android.content.Context context);
    method public void initialize(android.content.Context context, androidx.work.Configuration configuration);
    method public boolean isInitialized();
  }

  public enum WorkManager.UpdateResult {
    enum_constant public static final androidx.work.WorkManager.UpdateResult APPLIED_FOR_NEXT_RUN;
    enum_constant public static final androidx.work.WorkManager.UpdateResult APPLIED_IMMEDIATELY;
    enum_constant public static final androidx.work.WorkManager.UpdateResult NOT_APPLIED;
  }

  public final class WorkManagerInitializer implements androidx.startup.Initializer<androidx.work.WorkManager!> {
    ctor public WorkManagerInitializer();
    method public androidx.work.WorkManager create(android.content.Context);
    method public java.util.List<java.lang.Class<? extends androidx.startup.Initializer<? extends java.lang.Object!>!>!> dependencies();
  }

  public final class WorkQuery {
    method public static androidx.work.WorkQuery fromIds(java.util.List<java.util.UUID> ids);
    method public static androidx.work.WorkQuery fromIds(java.util.UUID... ids);
    method public static androidx.work.WorkQuery fromStates(androidx.work.WorkInfo.State... states);
    method public static androidx.work.WorkQuery fromStates(java.util.List<? extends androidx.work.WorkInfo.State> states);
    method public static androidx.work.WorkQuery fromTags(java.lang.String... tags);
    method public static androidx.work.WorkQuery fromTags(java.util.List<java.lang.String> tags);
    method public static androidx.work.WorkQuery fromUniqueWorkNames(java.lang.String... uniqueWorkNames);
    method public static androidx.work.WorkQuery fromUniqueWorkNames(java.util.List<java.lang.String> uniqueWorkNames);
    method public java.util.List<java.util.UUID> getIds();
    method public java.util.List<androidx.work.WorkInfo.State> getStates();
    method public java.util.List<java.lang.String> getTags();
    method public java.util.List<java.lang.String> getUniqueWorkNames();
    property public final java.util.List<java.util.UUID> ids;
    property public final java.util.List<androidx.work.WorkInfo.State> states;
    property public final java.util.List<java.lang.String> tags;
    property public final java.util.List<java.lang.String> uniqueWorkNames;
    field public static final androidx.work.WorkQuery.Companion Companion;
  }

  public static final class WorkQuery.Builder {
    method public androidx.work.WorkQuery.Builder addIds(java.util.List<java.util.UUID> ids);
    method public androidx.work.WorkQuery.Builder addStates(java.util.List<? extends androidx.work.WorkInfo.State> states);
    method public androidx.work.WorkQuery.Builder addTags(java.util.List<java.lang.String> tags);
    method public androidx.work.WorkQuery.Builder addUniqueWorkNames(java.util.List<java.lang.String> uniqueWorkNames);
    method public androidx.work.WorkQuery build();
    method public static androidx.work.WorkQuery.Builder fromIds(java.util.List<java.util.UUID> ids);
    method public static androidx.work.WorkQuery.Builder fromStates(java.util.List<? extends androidx.work.WorkInfo.State> states);
    method public static androidx.work.WorkQuery.Builder fromTags(java.util.List<java.lang.String> tags);
    method public static androidx.work.WorkQuery.Builder fromUniqueWorkNames(java.util.List<java.lang.String> uniqueWorkNames);
    field public static final androidx.work.WorkQuery.Builder.Companion Companion;
  }

  public static final class WorkQuery.Builder.Companion {
    method public androidx.work.WorkQuery.Builder fromIds(java.util.List<java.util.UUID> ids);
    method public androidx.work.WorkQuery.Builder fromStates(java.util.List<? extends androidx.work.WorkInfo.State> states);
    method public androidx.work.WorkQuery.Builder fromTags(java.util.List<java.lang.String> tags);
    method public androidx.work.WorkQuery.Builder fromUniqueWorkNames(java.util.List<java.lang.String> uniqueWorkNames);
  }

  public static final class WorkQuery.Companion {
    method public androidx.work.WorkQuery fromIds(java.util.List<java.util.UUID> ids);
    method public androidx.work.WorkQuery fromIds(java.util.UUID... ids);
    method public androidx.work.WorkQuery fromStates(androidx.work.WorkInfo.State... states);
    method public androidx.work.WorkQuery fromStates(java.util.List<? extends androidx.work.WorkInfo.State> states);
    method public androidx.work.WorkQuery fromTags(java.lang.String... tags);
    method public androidx.work.WorkQuery fromTags(java.util.List<java.lang.String> tags);
    method public androidx.work.WorkQuery fromUniqueWorkNames(java.lang.String... uniqueWorkNames);
    method public androidx.work.WorkQuery fromUniqueWorkNames(java.util.List<java.lang.String> uniqueWorkNames);
  }

  public abstract class WorkRequest {
    method public java.util.UUID getId();
    property public java.util.UUID id;
    field public static final androidx.work.WorkRequest.Companion Companion;
    field public static final long DEFAULT_BACKOFF_DELAY_MILLIS = 30000L; // 0x7530L
    field public static final long MAX_BACKOFF_MILLIS = 18000000L; // 0x112a880L
    field public static final long MIN_BACKOFF_MILLIS = 10000L; // 0x2710L
  }

  public abstract static class WorkRequest.Builder<B extends androidx.work.WorkRequest.Builder<B, ?>, W extends androidx.work.WorkRequest> {
    method public final B addTag(String tag);
    method public final W build();
    method @RequiresApi(26) public final B keepResultsForAtLeast(java.time.Duration duration);
    method public final B keepResultsForAtLeast(long duration, java.util.concurrent.TimeUnit timeUnit);
    method @RequiresApi(26) public final B setBackoffCriteria(androidx.work.BackoffPolicy backoffPolicy, java.time.Duration duration);
    method public final B setBackoffCriteria(androidx.work.BackoffPolicy backoffPolicy, long backoffDelay, java.util.concurrent.TimeUnit timeUnit);
    method public final B setConstraints(androidx.work.Constraints constraints);
    method public B setExpedited(androidx.work.OutOfQuotaPolicy policy);
    method public final B setId(java.util.UUID id);
    method @RequiresApi(26) public B setInitialDelay(java.time.Duration duration);
    method public B setInitialDelay(long duration, java.util.concurrent.TimeUnit timeUnit);
    method public final B setInputData(androidx.work.Data inputData);
    method public final B setTraceTag(String traceTag);
  }

  public static final class WorkRequest.Companion {
  }

  public abstract class Worker extends androidx.work.ListenableWorker {
    ctor public Worker(android.content.Context context, androidx.work.WorkerParameters workerParams);
    method @WorkerThread public abstract androidx.work.ListenableWorker.Result doWork();
    method @WorkerThread public androidx.work.ForegroundInfo getForegroundInfo();
    method public final com.google.common.util.concurrent.ListenableFuture<androidx.work.ListenableWorker.Result> startWork();
  }

  public final class WorkerExceptionInfo {
    ctor public WorkerExceptionInfo(String workerClassName, androidx.work.WorkerParameters workerParameters, Throwable throwable);
    method public Throwable getThrowable();
    method public String getWorkerClassName();
    method public androidx.work.WorkerParameters getWorkerParameters();
    property public final Throwable throwable;
    property public final String workerClassName;
    property public final androidx.work.WorkerParameters workerParameters;
  }

  public abstract class WorkerFactory {
    ctor public WorkerFactory();
    method public abstract androidx.work.ListenableWorker? createWorker(android.content.Context appContext, String workerClassName, androidx.work.WorkerParameters workerParameters);
  }

  public final class WorkerParameters {
    method @IntRange(from=0) public int getGeneration();
    method public java.util.UUID getId();
    method public androidx.work.Data getInputData();
    method @RequiresApi(28) public android.net.Network? getNetwork();
    method @IntRange(from=0) public int getRunAttemptCount();
    method public java.util.Set<java.lang.String!> getTags();
    method @RequiresApi(24) public java.util.List<java.lang.String!> getTriggeredContentAuthorities();
    method @RequiresApi(24) public java.util.List<android.net.Uri!> getTriggeredContentUris();
  }

  public final class WorkerParametersExtensions {
    method public static boolean isRemoteWorkRequest(androidx.work.WorkerParameters);
    method public static inline <reified T extends androidx.work.ListenableWorker> androidx.work.WorkerParameters usingRemoteService(androidx.work.WorkerParameters, android.content.ComponentName componentName);
    method public static androidx.work.WorkerParameters usingRemoteService(androidx.work.WorkerParameters, String workerClassName, android.content.ComponentName componentName);
  }

}

package androidx.work.multiprocess {

  public abstract class RemoteWorkContinuation {
    method public static androidx.work.multiprocess.RemoteWorkContinuation combine(java.util.List<androidx.work.multiprocess.RemoteWorkContinuation!>);
    method public abstract com.google.common.util.concurrent.ListenableFuture<java.lang.Void!> enqueue();
    method public final androidx.work.multiprocess.RemoteWorkContinuation then(androidx.work.OneTimeWorkRequest);
    method public abstract androidx.work.multiprocess.RemoteWorkContinuation then(java.util.List<androidx.work.OneTimeWorkRequest!>);
  }

  public abstract class RemoteWorkManager {
    method public final androidx.work.multiprocess.RemoteWorkContinuation beginUniqueWork(String, androidx.work.ExistingWorkPolicy, androidx.work.OneTimeWorkRequest);
    method public abstract androidx.work.multiprocess.RemoteWorkContinuation beginUniqueWork(String, androidx.work.ExistingWorkPolicy, java.util.List<androidx.work.OneTimeWorkRequest!>);
    method public final androidx.work.multiprocess.RemoteWorkContinuation beginWith(androidx.work.OneTimeWorkRequest);
    method public abstract androidx.work.multiprocess.RemoteWorkContinuation beginWith(java.util.List<androidx.work.OneTimeWorkRequest!>);
    method public abstract com.google.common.util.concurrent.ListenableFuture<java.lang.Void!> cancelAllWork();
    method public abstract com.google.common.util.concurrent.ListenableFuture<java.lang.Void!> cancelAllWorkByTag(String);
    method public abstract com.google.common.util.concurrent.ListenableFuture<java.lang.Void!> cancelUniqueWork(String);
    method public abstract com.google.common.util.concurrent.ListenableFuture<java.lang.Void!> cancelWorkById(java.util.UUID);
    method public abstract com.google.common.util.concurrent.ListenableFuture<java.lang.Void!> enqueue(androidx.work.WorkRequest);
    method public abstract com.google.common.util.concurrent.ListenableFuture<java.lang.Void!> enqueue(java.util.List<androidx.work.WorkRequest!>);
    method public abstract com.google.common.util.concurrent.ListenableFuture<java.lang.Void!> enqueueUniquePeriodicWork(String, androidx.work.ExistingPeriodicWorkPolicy, androidx.work.PeriodicWorkRequest);
    method public final com.google.common.util.concurrent.ListenableFuture<java.lang.Void!> enqueueUniqueWork(String, androidx.work.ExistingWorkPolicy, androidx.work.OneTimeWorkRequest);
    method public abstract com.google.common.util.concurrent.ListenableFuture<java.lang.Void!> enqueueUniqueWork(String, androidx.work.ExistingWorkPolicy, java.util.List<androidx.work.OneTimeWorkRequest!>);
    method public static androidx.work.multiprocess.RemoteWorkManager getInstance(android.content.Context);
    method public abstract com.google.common.util.concurrent.ListenableFuture<java.util.List<androidx.work.WorkInfo!>!> getWorkInfos(androidx.work.WorkQuery);
  }

}

